---
phase: 02-authentication-token-management
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/jobs/processors/tokenRefresh.ts
  - backend/src/jobs/queues.ts
  - backend/src/routes/admin.ts
  - backend/src/routes/mailbox.ts
  - backend/src/auth/routes.ts
  - backend/src/server.ts
autonomous: true
requirements: [AUTH-03, AUTH-05, AUTH-06]

must_haves:
  truths:
    - "Token refresh BullMQ worker proactively refreshes tokens for all connected mailboxes before expiry"
    - "When a refresh token expires, the mailbox is marked disconnected and a notification is created for the user"
    - "Admin can invite users by email and assign roles via /api/admin/* endpoints"
    - "User can connect additional mailboxes via /api/mailboxes/connect which initiates a new OAuth flow with prompt: 'select_account'"
    - "User can list their connected mailboxes and disconnect a mailbox"
    - "Non-admin users are blocked from admin-only routes by requireAdmin middleware"
  artifacts:
    - path: "backend/src/jobs/processors/tokenRefresh.ts"
      provides: "BullMQ processor that refreshes MSAL tokens for all connected mailboxes"
      exports: ["processTokenRefresh"]
    - path: "backend/src/routes/admin.ts"
      provides: "Admin user management API endpoints"
      contains: "/api/admin/invite, /api/admin/users"
    - path: "backend/src/routes/mailbox.ts"
      provides: "Mailbox connection management API endpoints"
      contains: "/api/mailboxes/connect, /api/mailboxes, /api/mailboxes/:id/disconnect"
  key_links:
    - from: "backend/src/jobs/processors/tokenRefresh.ts"
      to: "backend/src/auth/msalClient.ts"
      via: "createMsalClient() for acquireTokenSilent per mailbox"
      pattern: "createMsalClient.*acquireTokenSilent"
    - from: "backend/src/jobs/processors/tokenRefresh.ts"
      to: "backend/src/models/Notification.ts"
      via: "Creates token_expiring notification on refresh failure"
      pattern: "Notification\\.create.*token_expiring"
    - from: "backend/src/routes/mailbox.ts"
      to: "backend/src/auth/msalClient.ts"
      via: "createLoginMsalClient() for connect flow OAuth"
      pattern: "createLoginMsalClient|getAuthCodeUrl"
    - from: "backend/src/routes/mailbox.ts"
      to: "backend/src/auth/routes.ts"
      via: "OAuth callback handles connect_mailbox action"
      pattern: "connect_mailbox"
    - from: "backend/src/routes/admin.ts"
      to: "backend/src/auth/middleware.ts"
      via: "requireAdmin middleware protects all admin routes"
      pattern: "requireAdmin"
---

<objective>
Implement the token refresh BullMQ worker (replacing placeholder), admin user management routes, and multi-mailbox connection flow -- completing the authentication and token management stack.

Purpose: Tokens must be proactively refreshed so Graph API access continues without user intervention. Admins need to invite and manage users. Users need to connect multiple Microsoft 365 mailboxes with independent token sets.

Output: Working token refresh background job, admin invite/role/deactivate API, multi-mailbox connect/disconnect/list API, and the callback handler extended for connect_mailbox action.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-token-management/02-RESEARCH.md
@.planning/phases/02-authentication-token-management/02-01-SUMMARY.md
@backend/src/auth/msalClient.ts
@backend/src/auth/tokenManager.ts
@backend/src/auth/routes.ts
@backend/src/auth/middleware.ts
@backend/src/jobs/queues.ts
@backend/src/jobs/schedulers.ts
@backend/src/models/User.ts
@backend/src/models/Mailbox.ts
@backend/src/models/Notification.ts
@backend/src/middleware/errorHandler.ts
@backend/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement token refresh BullMQ worker processor</name>
  <files>
    backend/src/jobs/processors/tokenRefresh.ts
    backend/src/jobs/queues.ts
  </files>
  <action>
    1. Create directory `backend/src/jobs/processors/` if it does not exist.

    2. Create `backend/src/jobs/processors/tokenRefresh.ts`:
       - Import `Job` type from `bullmq`
       - Import `Mailbox` model, `Notification` model
       - Import `createMsalClient`, `GRAPH_SCOPES` from `../../auth/msalClient.js`
       - Import `isInteractionRequired` from `../../auth/tokenManager.js`
       - Import `logger` from `../../config/logger.js`

       - Define `REFRESH_THRESHOLD_MS = 15 * 60 * 1000` (15 minutes -- refresh tokens expiring within this window)

       - Export async function `processTokenRefresh(job: Job): Promise<void>`:
         - Log start: `logger.info('Token refresh job started', { jobId: job.id })`
         - Query all connected mailboxes with tokens expiring within the next 15 minutes OR with no expiresAt set (never refreshed):
           ```typescript
           const mailboxes = await Mailbox.find({
             isConnected: true,
             $or: [
               { 'encryptedTokens.expiresAt': { $lt: new Date(Date.now() + REFRESH_THRESHOLD_MS) } },
               { 'encryptedTokens.expiresAt': null },
             ],
           });
           ```
         - Track counts: `let refreshed = 0, failed = 0`
         - For each mailbox:
           - Try:
             - Create MSAL client: `const msalClient = createMsalClient(mailbox._id.toString())`
             - Get token cache: `const tokenCache = msalClient.getTokenCache()`
             - Get account: `const account = await tokenCache.getAccountByHomeId(mailbox.homeAccountId)`
             - If no account: call `markMailboxDisconnected(mailbox._id, 'Account not found in MSAL cache')`, increment failed, continue
             - Call `acquireTokenSilent({ account, scopes: GRAPH_SCOPES.filter(s => s !== 'offline_access') })`
             - Update mailbox expiry: `Mailbox.findByIdAndUpdate(mailbox._id, { 'encryptedTokens.expiresAt': result.expiresOn })`
             - Increment refreshed
           - Catch:
             - If `isInteractionRequired(err)`: call `markMailboxDisconnected(mailbox._id, 'Refresh token expired -- user must re-authenticate')` and create notification
             - Else: log error, increment failed (transient error -- will retry next cycle)
         - Log completion: `logger.info('Token refresh job completed', { jobId: job.id, refreshed, failed })`

       - Helper function `markMailboxDisconnected(mailboxId: Types.ObjectId, reason: string)`:
         - `await Mailbox.findByIdAndUpdate(mailboxId, { isConnected: false })`
         - Find the mailbox to get userId: `const mailbox = await Mailbox.findById(mailboxId).select('userId email')`
         - Create notification: `await Notification.create({ userId: mailbox.userId, type: 'token_expiring', title: 'Mailbox disconnected', message: \`Your mailbox ${mailbox.email} needs to be reconnected. Reason: ${reason}\`, priority: 'high' })`
         - Log: `logger.warn('Mailbox marked disconnected', { mailboxId: mailboxId.toString(), reason })`

    3. Update `backend/src/jobs/queues.ts`:
       - Import `processTokenRefresh` from `./processors/tokenRefresh.js`
       - Replace the placeholder processor for the 'token-refresh' worker. Currently all workers use `createProcessor(name)` (the placeholder). Change the workers array creation to use `processTokenRefresh` for the token-refresh queue while keeping placeholders for the other 4 queues.
       - Refactor the workers creation: instead of `.map()` on all QUEUE_NAMES with the same placeholder, create workers individually or use a mapping object:
         ```typescript
         const processorMap: Record<QueueName, (job: Job) => Promise<void>> = {
           'webhook-renewal': createProcessor('webhook-renewal'),
           'delta-sync': createProcessor('delta-sync'),
           'pattern-analysis': createProcessor('pattern-analysis'),
           'staging-processor': createProcessor('staging-processor'),
           'token-refresh': processTokenRefresh,
         };
         ```
       - Create workers using the processorMap instead of the generic createProcessor for all
       - Keep existing worker event handlers (completed, failed) for all workers
  </action>
  <verify>
    ```bash
    cd backend && npx tsc --noEmit
    ```
    TypeScript compiles. Verify:
    ```bash
    ls backend/src/jobs/processors/tokenRefresh.ts
    grep "processTokenRefresh" backend/src/jobs/queues.ts
    ```
  </verify>
  <done>
    - Token refresh processor finds mailboxes with expiring tokens and calls acquireTokenSilent via MSAL
    - Failed refresh (interaction_required) marks mailbox disconnected and creates high-priority notification
    - Token-refresh BullMQ worker uses real processor instead of placeholder
    - Other 4 queue workers still use placeholder processors (to be replaced in their respective phases)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admin routes, mailbox routes, and extend callback for multi-mailbox</name>
  <files>
    backend/src/routes/admin.ts
    backend/src/routes/mailbox.ts
    backend/src/auth/routes.ts
    backend/src/server.ts
  </files>
  <action>
    1. Create `backend/src/routes/admin.ts`:
       - Import `Router` from express, `User` model, `requireAuth` and `requireAdmin` from `../auth/middleware.js`
       - Import `ValidationError`, `NotFoundError` from `../middleware/errorHandler.js`, `logger`
       - Create `adminRouter = Router()`
       - Apply middleware to all routes: `adminRouter.use(requireAuth, requireAdmin)`

       **POST /api/admin/invite**:
       - Body: `{ email: string, role?: 'admin' | 'user' }`
       - Validate email is present and is a valid email format (simple regex)
       - Check if user with this email already exists -- if so, return 409 Conflict
       - Create user with `email: email.toLowerCase()`, `role: role || 'user'`, `isActive: true`, `invitedBy: req.user.userId`
       - Return 201 with the created user (id, email, role, isActive)

       **GET /api/admin/users**:
       - Query all users: `User.find().select('email displayName role isActive lastLoginAt createdAt').sort({ createdAt: -1 })`
       - Return array of users

       **PATCH /api/admin/users/:id/role**:
       - Body: `{ role: 'admin' | 'user' }`
       - Validate role is valid enum value
       - Prevent admin from demoting themselves: if `req.params.id === req.user.userId` and `role !== 'admin'`, return 400 "Cannot change your own role"
       - Find and update: `User.findByIdAndUpdate(req.params.id, { role }, { new: true })`
       - If not found, throw NotFoundError
       - Return updated user

       **PATCH /api/admin/users/:id/deactivate**:
       - Prevent admin from deactivating themselves: if `req.params.id === req.user.userId`, return 400
       - Find and update: `User.findByIdAndUpdate(req.params.id, { isActive: false }, { new: true })`
       - If not found, throw NotFoundError
       - Return updated user

       Export `adminRouter` as default

    2. Create `backend/src/routes/mailbox.ts`:
       - Import `Router` from express, `Mailbox` model, `requireAuth` from `../auth/middleware.js`
       - Import `createLoginMsalClient`, `GRAPH_SCOPES` from `../auth/msalClient.js`
       - Import `config`, `logger`, `jwt` from jsonwebtoken
       - Import `NotFoundError`, `ValidationError` from `../middleware/errorHandler.js`
       - Create `mailboxRouter = Router()`
       - Apply middleware to all routes: `mailboxRouter.use(requireAuth)`

       **POST /api/mailboxes/connect**:
       - Body: optional `{ loginHint?: string }` (target email for the account picker)
       - Create a signed JWT state parameter containing `{ action: 'connect_mailbox', userId: req.user.userId, ts: Date.now() }` signed with `config.jwtSecret` with 10 min expiry
       - Create login MSAL client via `createLoginMsalClient()`
       - Build auth URL params: `{ scopes: GRAPH_SCOPES, redirectUri: \`${config.apiUrl}/auth/callback\`, state: stateToken, prompt: 'select_account' }`
       - If `loginHint` provided, add `loginHint` to params
       - Call `msalClient.getAuthCodeUrl(params)`
       - Return `{ authUrl }` (frontend will redirect the user)

       **GET /api/mailboxes**:
       - Query: `Mailbox.find({ userId: req.user.userId }).select('email displayName isConnected homeAccountId tenantId lastSyncAt settings createdAt').sort({ createdAt: 1 })`
       - Return array of mailboxes

       **DELETE /api/mailboxes/:id/disconnect**:
       - Find mailbox by ID and verify ownership: `Mailbox.findOne({ _id: req.params.id, userId: req.user.userId })`
       - If not found, throw NotFoundError
       - Update: set `isConnected: false`, clear `msalCache: null`, clear `encryptedTokens: {}`
       - Return `{ message: 'Mailbox disconnected', mailboxId: req.params.id }`

       Export `mailboxRouter` as default

    3. Update `backend/src/auth/routes.ts` -- extend the callback handler for `connect_mailbox` action:
       - In the GET /auth/callback handler, after the state is validated and parsed:
       - If `stateData.action === 'connect_mailbox'`:
         - Verify `stateData.userId` exists (required for connect flow)
         - Verify the user making this request is the same user who initiated it (security: check that a User exists with this userId and is active)
         - Extract account from tokenResponse
         - Check if a mailbox with this email already exists for this user: `Mailbox.findOne({ userId: stateData.userId, email: account.username.toLowerCase() })`. If exists and isConnected, redirect with `error=mailbox_already_connected`
         - If exists but disconnected, reconnect: update `isConnected: true`, `homeAccountId: account.homeAccountId`, `tenantId: account.tenantId`, save MSAL cache
         - If not exists, create new Mailbox: `{ userId: stateData.userId, email: account.username.toLowerCase(), displayName: account.name, homeAccountId: account.homeAccountId, tenantId: account.tenantId, isConnected: true }`
         - Save MSAL cache to mailbox: `Mailbox.findByIdAndUpdate(mailbox._id, { msalCache: loginMsalClient.getTokenCache().serialize(), 'encryptedTokens.expiresAt': tokenResponse.expiresOn })`
         - Redirect to `${config.appUrl}/settings?connected=${account.username}` (or just `config.appUrl`)
       - Remove the temporary "unsupported_action" redirect for connect_mailbox

    4. Update `backend/src/server.ts`:
       - Import `adminRouter` from `./routes/admin.js`
       - Import `mailboxRouter` from `./routes/mailbox.js`
       - Mount after auth routes and after requireAuth:
         - `app.use('/api/admin', adminRouter)` (adminRouter already applies requireAuth + requireAdmin internally)
         - `app.use('/api/mailboxes', mailboxRouter)` (mailboxRouter already applies requireAuth internally)
       - These should be mounted before the global error handler but after the rate limiters
       - Note: The requireAuth in server.ts on `/api` may conflict with adminRouter/mailboxRouter's own requireAuth. To avoid double-auth, do NOT apply blanket `app.use('/api', requireAuth)` on the server level. Instead, let each route file apply its own auth middleware. The health endpoint is already exempt because it's mounted first.
  </action>
  <verify>
    ```bash
    cd backend && npx tsc --noEmit
    ```
    TypeScript compiles. Verify route mounting:
    ```bash
    grep -r "adminRouter\|mailboxRouter" backend/src/server.ts
    grep "connect_mailbox" backend/src/auth/routes.ts
    ```
  </verify>
  <done>
    - POST /api/admin/invite creates invited user with email and role
    - GET /api/admin/users lists all users (admin only)
    - PATCH /api/admin/users/:id/role changes user role (admin only, cannot self-demote)
    - PATCH /api/admin/users/:id/deactivate deactivates user (admin only, cannot self-deactivate)
    - POST /api/mailboxes/connect returns auth URL for connecting additional mailbox
    - GET /api/mailboxes lists user's connected mailboxes
    - DELETE /api/mailboxes/:id/disconnect disconnects a mailbox and clears tokens
    - OAuth callback handles connect_mailbox action: creates/reconnects Mailbox, persists MSAL cache
    - All admin routes protected by requireAuth + requireAdmin
    - All mailbox routes protected by requireAuth
  </done>
</task>

</tasks>

<verification>
1. `cd backend && npx tsc --noEmit` -- TypeScript compiles without errors
2. `ls backend/src/jobs/processors/` -- Contains tokenRefresh.ts
3. `ls backend/src/routes/` -- Contains admin.ts, mailbox.ts
4. `grep "processTokenRefresh" backend/src/jobs/queues.ts` -- Real processor wired to token-refresh worker
5. `grep "connect_mailbox" backend/src/auth/routes.ts` -- Callback handles multi-mailbox connection
6. `grep "adminRouter\|mailboxRouter" backend/src/server.ts` -- Routes mounted in server
7. `grep "requireAdmin" backend/src/routes/admin.ts` -- Admin routes protected
</verification>

<success_criteria>
- Token refresh worker proactively refreshes tokens using acquireTokenSilent via MSAL cache
- Expired refresh tokens trigger mailbox disconnection + user notification
- Admin user management: invite, list, change role, deactivate (all admin-only)
- Multi-mailbox: connect initiates new OAuth flow, callback creates Mailbox with per-mailbox MSAL cache
- Disconnect clears tokens and MSAL cache from mailbox
- Self-protection: admin cannot demote/deactivate themselves
- TypeScript compiles cleanly with strict mode
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-token-management/02-02-SUMMARY.md`
</output>
