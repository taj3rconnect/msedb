---
phase: 02-authentication-token-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/package.json
  - backend/src/auth/msalClient.ts
  - backend/src/auth/tokenManager.ts
  - backend/src/auth/routes.ts
  - backend/src/auth/middleware.ts
  - backend/src/models/Mailbox.ts
  - backend/src/models/Notification.ts
  - backend/src/server.ts
autonomous: true
requirements: [AUTH-01, AUTH-02, AUTH-04]

user_setup:
  - service: azure-ad
    why: "Azure AD app registration required for OAuth 2.0 flow"
    env_vars:
      - name: AZURE_AD_TENANT_ID
        source: "Azure Portal -> App registrations -> Overview -> Directory (tenant) ID"
      - name: AZURE_AD_CLIENT_ID
        source: "Azure Portal -> App registrations -> Overview -> Application (client) ID"
      - name: AZURE_AD_CLIENT_SECRET
        source: "Azure Portal -> App registrations -> Certificates & secrets -> New client secret"
      - name: JWT_SECRET
        source: "Generate with: openssl rand -hex 64"
      - name: ADMIN_EMAIL
        source: "The Microsoft 365 email address that should get admin role on first login"
    dashboard_config:
      - task: "Create app registration"
        location: "Azure Portal -> App registrations -> New registration"
        details: "Name: MSEDB, Supported account types: Accounts in this organizational directory only (single tenant), Redirect URI: Web -> http://localhost:8010/auth/callback"
      - task: "Configure API permissions"
        location: "Azure Portal -> App registrations -> MSEDB -> API permissions -> Add a permission -> Microsoft Graph -> Delegated permissions"
        details: "Add: User.Read, Mail.Read, Mail.ReadWrite, Mail.Send, MailboxSettings.ReadWrite, offline_access. Then click 'Grant admin consent'"
      - task: "Create client secret"
        location: "Azure Portal -> App registrations -> MSEDB -> Certificates & secrets -> New client secret"
        details: "Set expiration to 24 months. Copy the Value (not Secret ID) immediately -- it is only shown once"

must_haves:
  truths:
    - "User can click 'Sign in with Microsoft' and be redirected to Azure AD login page"
    - "After Azure AD authentication, user lands back on the app with a valid JWT session cookie"
    - "Browser refresh does not lose the session -- requireAuth middleware validates the JWT cookie on every request"
    - "MSAL cache is persisted to MongoDB via ICachePlugin -- survives container restarts"
    - "Admin user (matching ADMIN_EMAIL) gets admin role on first login"
  artifacts:
    - path: "backend/src/auth/msalClient.ts"
      provides: "ConfidentialClientApplication factory with MongoDBCachePlugin"
      exports: ["createMsalClient", "MongoDBCachePlugin", "GRAPH_SCOPES"]
    - path: "backend/src/auth/tokenManager.ts"
      provides: "Token encryption/decryption helpers and acquireTokenSilent wrapper"
      exports: ["getAccessTokenForMailbox", "encryptTokenData", "decryptTokenData"]
    - path: "backend/src/auth/routes.ts"
      provides: "OAuth login, callback, logout, and session info endpoints"
      contains: "/auth/login, /auth/callback, /auth/logout, /auth/me"
    - path: "backend/src/auth/middleware.ts"
      provides: "JWT verification and role-based access control middleware"
      exports: ["requireAuth", "requireAdmin"]
  key_links:
    - from: "backend/src/auth/routes.ts"
      to: "backend/src/auth/msalClient.ts"
      via: "createMsalClient() for OAuth flow"
      pattern: "createMsalClient"
    - from: "backend/src/auth/routes.ts"
      to: "backend/src/models/User.ts"
      via: "findOne/create User on callback"
      pattern: "User\\.findOne|User\\.create"
    - from: "backend/src/auth/middleware.ts"
      to: "JWT cookie"
      via: "jwt.verify on req.cookies.msedb_session"
      pattern: "jwt\\.verify.*msedb_session"
    - from: "backend/src/auth/msalClient.ts"
      to: "backend/src/models/Mailbox.ts"
      via: "ICachePlugin reads/writes Mailbox.msalCache"
      pattern: "Mailbox\\.findById.*msalCache"
---

<objective>
Implement the full Azure AD OAuth 2.0 authentication flow with MSAL Node, JWT session management via httpOnly cookies, auth middleware, and MSAL cache persistence to MongoDB.

Purpose: Users need to authenticate via Microsoft identity to access the dashboard, and their MSAL tokens must survive container restarts via the ICachePlugin persisting to MongoDB.

Output: Working OAuth login/callback/logout endpoints, requireAuth/requireAdmin middleware, MongoDBCachePlugin for MSAL cache persistence, token encryption helpers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-token-management/02-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-03-SUMMARY.md
@backend/src/config/index.ts
@backend/src/server.ts
@backend/src/models/User.ts
@backend/src/models/Mailbox.ts
@backend/src/models/Notification.ts
@backend/src/utils/encryption.ts
@backend/src/middleware/errorHandler.ts
@backend/src/middleware/security.ts
@backend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create MSAL client factory with MongoDB cache plugin</name>
  <files>
    backend/package.json
    backend/src/auth/msalClient.ts
    backend/src/auth/tokenManager.ts
    backend/src/models/Mailbox.ts
    backend/src/models/Notification.ts
  </files>
  <action>
    1. Install dependencies in backend/:
       ```bash
       cd backend && npm install @azure/msal-node@^3 jsonwebtoken cookie-parser uuid && npm install -D @types/jsonwebtoken @types/cookie-parser
       ```

    2. Create `backend/src/auth/msalClient.ts`:
       - Import `ConfidentialClientApplication`, `ICachePlugin`, `TokenCacheContext`, `LogLevel` from `@azure/msal-node`
       - Import `Mailbox` model and `config`
       - Define `GRAPH_SCOPES` constant: `['User.Read', 'Mail.Read', 'Mail.ReadWrite', 'Mail.Send', 'MailboxSettings.ReadWrite', 'offline_access']`
       - Create `MongoDBCachePlugin` class implementing `ICachePlugin`:
         - Constructor takes `mailboxId: string`
         - `beforeCacheAccess(cacheContext: TokenCacheContext)`: Load `Mailbox.findById(this.mailboxId).select('msalCache')`, if msalCache exists, call `cacheContext.tokenCache.deserialize(mailbox.msalCache)`
         - `afterCacheAccess(cacheContext: TokenCacheContext)`: If `cacheContext.cacheHasChanged`, call `Mailbox.findByIdAndUpdate(this.mailboxId, { msalCache: cacheContext.tokenCache.serialize() })`
       - Create `createMsalClient(mailboxId: string): ConfidentialClientApplication` factory function:
         - Uses `config.azureAdClientId`, authority `https://login.microsoftonline.com/${config.azureAdTenantId}`, `config.azureAdClientSecret`
         - Passes `new MongoDBCachePlugin(mailboxId)` as `cache.cachePlugin`
         - Configures MSAL logger to route to Winston at Warning level, `piiLoggingEnabled: false`
       - Create `createLoginMsalClient(): ConfidentialClientApplication` for initial login (no mailbox yet, no cache plugin):
         - Same auth config but no cache plugin (cache will be assigned after mailbox creation)
       - Export: `createMsalClient`, `createLoginMsalClient`, `MongoDBCachePlugin`, `GRAPH_SCOPES`

    3. Create `backend/src/auth/tokenManager.ts`:
       - Import `encrypt`, `decrypt` from `../utils/encryption.js`
       - Import `config` from `../config/index.js`
       - Import `createMsalClient`, `GRAPH_SCOPES` from `./msalClient.js`
       - Import `Mailbox` model
       - Create `encryptTokenData(plaintext: string): { encrypted: string; iv: string; tag: string }` -- wraps `encrypt(plaintext, config.encryptionKey)`
       - Create `decryptTokenData(data: { encrypted: string; iv: string; tag: string }): string` -- wraps `decrypt(data.encrypted, data.iv, data.tag, config.encryptionKey)`
       - Create `getAccessTokenForMailbox(mailboxId: string): Promise<string>`:
         - Find mailbox by ID, throw if not found
         - Create MSAL client via `createMsalClient(mailboxId)`
         - Get token cache, call `getAccountByHomeId(mailbox.homeAccountId)`
         - If no account, throw error "Account not found in cache -- re-authentication required"
         - Call `acquireTokenSilent({ account, scopes: GRAPH_SCOPES.filter(s => s !== 'offline_access') })`
         - Return `silentResult.accessToken`
       - Create helper `isInteractionRequired(error: unknown): boolean` -- checks error message/code for 'interaction_required', 'login_required', 'consent_required'
       - Export all functions

    4. Update `backend/src/models/Mailbox.ts`:
       - Add `homeAccountId?: string` field to `IMailbox` interface
       - Add `homeAccountId: { type: String }` to mailbox schema
       - Add sparse unique index BEFORE the `export const Mailbox = model<IMailbox>('Mailbox', mailboxSchema)` line, alongside the existing `mailboxSchema.index(...)` declarations: `mailboxSchema.index({ homeAccountId: 1 }, { unique: true, sparse: true })`

    5. Update `backend/src/models/Notification.ts`:
       - Add `'token_expiring'` to the INotification type enum union
       - Add `'token_expiring'` to the schema enum array
  </action>
  <verify>
    Run from the backend directory:
    ```bash
    cd backend && npx tsc --noEmit
    ```
    TypeScript compiles without errors. Verify @azure/msal-node is in package.json dependencies at ^3.x.
  </verify>
  <done>
    - `msalClient.ts` exports `createMsalClient`, `createLoginMsalClient`, `MongoDBCachePlugin`, `GRAPH_SCOPES`
    - `tokenManager.ts` exports `getAccessTokenForMailbox`, `encryptTokenData`, `decryptTokenData`, `isInteractionRequired`
    - Mailbox model has `homeAccountId` field with sparse unique index
    - Notification model accepts `token_expiring` type
    - All dependencies installed and TypeScript compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth routes, JWT middleware, and mount in server</name>
  <files>
    backend/src/auth/routes.ts
    backend/src/auth/middleware.ts
    backend/src/server.ts
  </files>
  <action>
    1. Create `backend/src/auth/middleware.ts`:
       - Import `jwt` from `jsonwebtoken` (default import), types from express, `UnauthorizedError` and `ForbiddenError` from `../middleware/errorHandler.js`, `config`
       - Define `JwtPayload` interface: `{ userId: string; email: string; role: 'admin' | 'user' }`
       - Augment Express Request type globally: `declare global { namespace Express { interface Request { user?: JwtPayload; } } }`
       - `requireAuth(req, res, next)`: Read `req.cookies?.msedb_session`, if missing throw `UnauthorizedError('No session token')`. Try `jwt.verify(token, config.jwtSecret) as JwtPayload`, set `req.user = decoded`, call `next()`. On error throw `UnauthorizedError('Invalid or expired session')`
       - `requireAdmin(req, res, next)`: If `req.user?.role !== 'admin'` throw `ForbiddenError('Admin access required')`. Otherwise `next()`
       - Export both middleware functions

    2. Create `backend/src/auth/routes.ts`:
       - Import Router from express, `jwt` from jsonwebtoken, `config`, `logger`, `User` model, `Mailbox` model
       - Import `createLoginMsalClient`, `createMsalClient`, `GRAPH_SCOPES` from `./msalClient.js`
       - Import `encryptTokenData` from `./tokenManager.js`
       - Import `requireAuth` from `./middleware.js`
       - Create `authRouter = Router()`

       **GET /auth/login**:
       - Create a signed JWT state parameter containing `{ action: 'login', ts: Date.now() }` signed with `config.jwtSecret` and 10 min expiry
       - Create login MSAL client via `createLoginMsalClient()`
       - Call `msalClient.getAuthCodeUrl({ scopes: GRAPH_SCOPES, redirectUri: \`${config.apiUrl}/auth/callback\`, state: stateToken, prompt: 'select_account' })`
       - Redirect user to the auth URL

       **GET /auth/callback**:
       - Extract `code`, `state`, `error`, `error_description` from `req.query`
       - If `error`, log it and redirect to `${config.appUrl}/login?error=${error}`
       - Validate `state` by verifying the JWT signature with `config.jwtSecret`. If invalid/expired, redirect with `error=invalid_state`
       - Parse state to get `action` (login vs connect_mailbox) and optional `userId`
       - Create login MSAL client, call `acquireTokenByCode({ code, scopes: GRAPH_SCOPES, redirectUri: \`${config.apiUrl}/auth/callback\` })`
       - Extract `account` from token response (account.localAccountId = microsoftId, account.username = email, account.name = displayName, account.homeAccountId, account.tenantId)
       - If `action === 'login'`:
         - Find or create User: `User.findOne({ microsoftId: account.localAccountId })`. If not found, create with `email: account.username.toLowerCase()`, `microsoftId: account.localAccountId`, `displayName: account.name`, `role: account.username.toLowerCase() === config.adminEmail.toLowerCase() ? 'admin' : 'user'`
         - Update `lastLoginAt: new Date()`
         - Find or create initial Mailbox for this user+email: `Mailbox.findOne({ userId: user._id, email: account.username.toLowerCase() })`. If not found, create with `userId: user._id`, `email: account.username.toLowerCase()`, `displayName: account.name`, `homeAccountId: account.homeAccountId`, `tenantId: account.tenantId`, `isConnected: true`
         - Persist MSAL cache to the mailbox: After creating/finding the mailbox, save the MSAL token cache from the login client to the mailbox's msalCache field. Use `loginMsalClient.getTokenCache().serialize()` and store it on the Mailbox document.
         - Also encrypt and store the access token expiry: `Mailbox.findByIdAndUpdate(mailbox._id, { msalCache: loginMsalClient.getTokenCache().serialize(), 'encryptedTokens.expiresAt': tokenResponse.expiresOn })`
       - Sign JWT session token: `jwt.sign({ userId: user._id.toString(), email: user.email, role: user.role }, config.jwtSecret, { expiresIn: '24h' })`
       - Set httpOnly cookie: `res.cookie('msedb_session', sessionToken, { httpOnly: true, secure: config.nodeEnv === 'production', sameSite: 'lax', maxAge: 24 * 60 * 60 * 1000, path: '/' })`
       - Redirect to `config.appUrl`
       - If `action === 'connect_mailbox'`: handled in Plan 02-02 (routes/mailbox.ts). For now, redirect to appUrl with error=unsupported_action

       **POST /auth/logout** (requires requireAuth):
       - Clear the session cookie: `res.clearCookie('msedb_session', { httpOnly: true, secure: config.nodeEnv === 'production', sameSite: 'lax', path: '/' })`
       - Return `{ message: 'Logged out' }`

       **GET /auth/me** (requires requireAuth):
       - Find user by `req.user.userId` from the JWT payload
       - Return user's email, displayName, role, preferences, and list of connected mailboxes (basic info: id, email, displayName, isConnected)
       - Populate mailboxes via `Mailbox.find({ userId: req.user.userId }).select('email displayName isConnected')`

       Export `authRouter` as default

    3. Update `backend/src/server.ts`:
       - Add `import cookieParser from 'cookie-parser'` at the top
       - Add `app.use(cookieParser())` right after `configureSecurityMiddleware(app)` and before route mounting
       - Import `authRouter` from `./auth/routes.js`
       - Import `{ requireAuth }` from `./auth/middleware.js`
       - Mount auth router: `app.use(authRouter)` before the error handler, AFTER cookie-parser
       - Apply rate limiter: Keep existing `app.use('/auth', createAuthLimiter())` which will apply to auth routes
       - Do NOT apply blanket `app.use('/api', requireAuth)` at the server level. Auth will be applied at the route level by each route file (e.g., `adminRouter.use(requireAuth, requireAdmin)`, `mailboxRouter.use(requireAuth)`). This avoids double-auth and gives each route file explicit control.
  </action>
  <verify>
    Run from the backend directory:
    ```bash
    cd backend && npx tsc --noEmit
    ```
    TypeScript compiles without errors. Verify auth routes are mounted in server.ts with cookie-parser middleware.

    Quick check the structure:
    ```bash
    ls backend/src/auth/
    ```
    Should show: middleware.ts, msalClient.ts, routes.ts, tokenManager.ts
  </verify>
  <done>
    - GET /auth/login redirects to Azure AD with signed state JWT
    - GET /auth/callback exchanges code for tokens, creates/finds User and Mailbox, persists MSAL cache, issues JWT in httpOnly cookie, redirects to frontend
    - POST /auth/logout clears session cookie
    - GET /auth/me returns user info and connected mailboxes (protected by requireAuth)
    - requireAuth middleware validates JWT from httpOnly cookie on every protected request
    - requireAdmin middleware blocks non-admin users
    - cookie-parser is mounted in server.ts before auth routes
    - Auth is NOT applied at the server level; each route file applies its own auth middleware (route-level auth only)
  </done>
</task>

</tasks>

<verification>
1. `cd backend && npx tsc --noEmit` -- TypeScript compiles without errors
2. `ls backend/src/auth/` -- Contains msalClient.ts, tokenManager.ts, routes.ts, middleware.ts
3. `grep -r "cookie-parser" backend/src/server.ts` -- cookie-parser is imported and used
4. `grep -r "authRouter" backend/src/server.ts` -- auth routes are mounted
5. `grep -v "requireAuth" backend/src/server.ts` -- Confirm NO blanket `app.use('/api', requireAuth)` at server level (route-level auth only)
6. `grep -r "homeAccountId" backend/src/models/Mailbox.ts` -- Field exists on model
7. `grep -r "token_expiring" backend/src/models/Notification.ts` -- Type exists in enum
</verification>

<success_criteria>
- MSAL ConfidentialClientApplication factory creates per-mailbox instances with MongoDB cache plugin
- OAuth login/callback flow redirects to Azure AD and handles token exchange
- JWT session token issued in httpOnly cookie with 24h expiry
- requireAuth middleware available for route-level application (NOT applied as blanket server middleware)
- requireAdmin middleware blocks non-admin access
- MSAL cache serialized to Mailbox.msalCache on every token operation
- Mailbox model has homeAccountId with sparse unique index
- TypeScript compiles cleanly with strict mode
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-token-management/02-01-SUMMARY.md`
</output>
