---
phase: 07-polish-notifications-admin
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/notificationService.ts
  - backend/src/routes/notifications.ts
  - backend/src/routes/settings.ts
  - backend/src/routes/admin.ts
  - backend/src/models/Rule.ts
  - backend/src/server.ts
  - frontend/src/components/ui/popover.tsx
  - frontend/src/components/ui/tabs.tsx
  - frontend/src/components/ui/dialog.tsx
  - frontend/src/components/ui/label.tsx
  - frontend/src/components/ui/slider.tsx
  - frontend/src/components/ui/radio-group.tsx
  - frontend/src/components/ui/textarea.tsx
  - frontend/src/components/ui/progress.tsx
autonomous: true
requirements:
  - DASH-03
  - PAGE-06
  - PAGE-07

must_haves:
  truths:
    - "Notification CRUD API returns paginated notifications with unread count"
    - "Notification service creates a document AND emits Socket.IO event in one call"
    - "Settings API expands user preferences to handle all fields (not just automationPaused)"
    - "Data export endpoint returns downloadable JSON of all user data"
    - "Data delete endpoint removes all user data and clears session"
    - "Admin analytics endpoint returns aggregate counts across all users"
    - "Admin system health endpoint returns per-mailbox webhook status and per-user token health"
    - "Admin can create org-wide rules (scope: org) without a mailboxId"
  artifacts:
    - path: "backend/src/services/notificationService.ts"
      provides: "Centralized notification create + Socket.IO emit"
      exports: ["createNotification"]
    - path: "backend/src/routes/notifications.ts"
      provides: "Notification CRUD routes"
      exports: ["notificationsRouter"]
    - path: "backend/src/routes/settings.ts"
      provides: "Settings API routes"
      exports: ["settingsRouter"]
  key_links:
    - from: "backend/src/services/notificationService.ts"
      to: "backend/src/config/socket.ts"
      via: "getIO() for Socket.IO emission"
      pattern: "getIO\\(\\).*emit.*notification:new"
    - from: "backend/src/routes/notifications.ts"
      to: "backend/src/models/Notification.ts"
      via: "Mongoose queries"
      pattern: "Notification\\.(find|countDocuments|findOneAndUpdate|updateMany)"
    - from: "backend/src/routes/settings.ts"
      to: "backend/src/models/User.ts"
      via: "Mongoose findByIdAndUpdate with $set"
      pattern: "User\\.findByIdAndUpdate"
    - from: "backend/src/server.ts"
      to: "backend/src/routes/notifications.ts"
      via: "app.use('/api/notifications')"
      pattern: "app\\.use.*notifications"
---

<objective>
Build all backend API routes and the centralized notification service for Phase 7, plus install the shadcn/ui components needed by the frontend plans.

Purpose: The frontend plans (07-02 and 07-03) need backend endpoints to consume. Building all backend work in one plan ensures the API surface is complete before any UI work begins.

Output: notificationService, notification CRUD routes, settings routes (preferences expansion + data export/delete), admin analytics/health/org-rules endpoints, Rule model mailboxId optional for org scope, shadcn components installed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-polish-notifications-admin/07-RESEARCH.md
@backend/src/server.ts
@backend/src/routes/admin.ts
@backend/src/routes/user.ts
@backend/src/models/Notification.ts
@backend/src/models/User.ts
@backend/src/models/Rule.ts
@backend/src/models/Mailbox.ts
@backend/src/models/WebhookSubscription.ts
@backend/src/config/socket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notification service, notification CRUD routes, and shadcn components</name>
  <files>
    backend/src/services/notificationService.ts
    backend/src/routes/notifications.ts
    backend/src/server.ts
  </files>
  <action>
    **Install shadcn components** in the frontend directory:
    ```bash
    cd frontend && npx shadcn@latest add popover tabs dialog label slider radio-group textarea progress
    ```

    **Create `backend/src/services/notificationService.ts`:**
    - Export `createNotification(params)` function accepting: `userId` (string), `type` (INotification['type']), `title` (string), `message` (string), optional `priority` (default 'normal'), optional `relatedEntity`.
    - Creates a `Notification` document via `Notification.create()`.
    - After creation, emits `notification:new` via Socket.IO to `user:{userId}` room using `getIO()` from `config/socket.ts`.
    - Wrap the Socket.IO emission in try/catch (silent on failure -- may not be initialized in tests or worker processes).
    - Emit payload: `{ id, type, title, message, priority, isRead: false, createdAt, relatedEntity }`.
    - Return the created notification document.
    - Follow the exact pattern from 07-RESEARCH.md Pattern 1.

    **Create `backend/src/routes/notifications.ts`:**
    - Export `notificationsRouter` (Router).
    - Apply `requireAuth` middleware on the router.
    - Implement these endpoints:

    1. `GET /` -- List notifications for the authenticated user.
       - Query params: `limit` (default 20, max 50), `offset` (default 0).
       - Run three parallel queries: `Notification.find({userId}).sort({createdAt:-1}).skip(offset).limit(limit).lean()`, `Notification.countDocuments({userId})`, `Notification.countDocuments({userId, isRead:false})`.
       - Return `{ notifications, total, unreadCount }`.

    2. `GET /unread-count` -- Return unread count only.
       - Define BEFORE any `/:id` routes.
       - Return `{ count }` from `Notification.countDocuments({userId, isRead:false})`.

    3. `PATCH /read-all` -- Mark all notifications as read.
       - Define BEFORE any `/:id` routes.
       - `Notification.updateMany({userId, isRead:false}, {isRead:true, readAt:new Date()})`.
       - Return `{ success: true }`.

    4. `PATCH /:id/read` -- Mark single notification as read.
       - `Notification.findOneAndUpdate({_id:req.params.id, userId}, {isRead:true, readAt:new Date()}, {new:true})`.
       - Return 404 if not found.

    Route ordering: `GET /unread-count` and `PATCH /read-all` MUST be defined before `PATCH /:id/read` to prevent Express param capture (per decision pattern from Phase 05 and 06).

    **Mount in `backend/src/server.ts`:**
    - Import `notificationsRouter` from `./routes/notifications.js`.
    - Add `app.use('/api/notifications', notificationsRouter);` after the audit router mount.
  </action>
  <verify>
    - `ls frontend/src/components/ui/popover.tsx frontend/src/components/ui/tabs.tsx frontend/src/components/ui/dialog.tsx frontend/src/components/ui/label.tsx frontend/src/components/ui/slider.tsx frontend/src/components/ui/radio-group.tsx frontend/src/components/ui/textarea.tsx frontend/src/components/ui/progress.tsx` -- all 8 files exist.
    - `npx tsc --noEmit --project backend/tsconfig.json` passes (notification service and routes compile).
    - Grep `notificationsRouter` in `backend/src/server.ts` confirms it's mounted.
  </verify>
  <done>
    Centralized notificationService creates notifications with Socket.IO emission. Notification CRUD routes handle list, unread-count, mark-read, mark-all-read. All 8 shadcn components installed. Routes mounted in server.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Settings routes, admin extensions, and Rule model update</name>
  <files>
    backend/src/routes/settings.ts
    backend/src/routes/user.ts
    backend/src/routes/admin.ts
    backend/src/models/Rule.ts
    backend/src/server.ts
  </files>
  <action>
    **Update `backend/src/models/Rule.ts`:**
    - Make `mailboxId` optional in the IRule interface: `mailboxId?: Types.ObjectId`.
    - In the schema, change mailboxId from `required: true` to `required: false` so org-scoped rules can omit it.
    - This is needed because org-wide rules (scope: 'org') apply across all mailboxes and should not be tied to a specific mailbox.

    **Expand `backend/src/routes/user.ts`:**
    - Update the `PATCH /preferences` endpoint to accept ALL preference fields, not just `automationPaused`.
    - Accept: `automationPaused` (boolean), `workingHoursStart` (number 0-23), `workingHoursEnd` (number 0-23), `aggressiveness` ('conservative'|'moderate'|'aggressive').
    - Build a dynamic `updateFields` object -- only include fields that were actually provided in the request body. Use `$set` with dot-notation keys like `'preferences.automationPaused'`.
    - Validate types: `workingHoursStart` and `workingHoursEnd` must be numbers 0-23 if provided. `aggressiveness` must be one of the three valid values if provided. `automationPaused` must be boolean if provided.
    - If no valid fields provided, return 400.
    - This prevents the kill switch overwrite pitfall (Research Pitfall 3): only provided fields are updated.

    **Create `backend/src/routes/settings.ts`:**
    - Export `settingsRouter` (Router).
    - Apply `requireAuth` middleware.
    - Implement:

    1. `GET /` -- Return current user settings.
       - Query User by userId, select `email displayName preferences createdAt`.
       - Query Mailbox by userId, select `email displayName isConnected encryptedTokens.expiresAt lastSyncAt settings createdAt`.
       - Return `{ user, mailboxes }`. For mailboxes, map to safe shape: `{ id, email, displayName, isConnected, tokenExpiresAt: m.encryptedTokens?.expiresAt, tokenHealthy: isConnected && expiresAt > now, lastSyncAt, whitelistedSenders: m.settings.whitelistedSenders, whitelistedDomains: m.settings.whitelistedDomains }`. NEVER expose encrypted token data.

    2. `GET /export-data` -- Export all user data as downloadable JSON.
       - Parallel queries: User (select 'email displayName preferences createdAt'), Mailbox (select 'email displayName settings createdAt'), Rule (select '-__v'), Pattern (select '-__v'), EmailEvent (sort createdAt desc, limit 10000, select '-__v'), AuditLog (sort createdAt desc, limit 5000, select '-__v').
       - Set `Content-Type: application/json` and `Content-Disposition: attachment; filename="msedb-export-YYYY-MM-DD.json"`.
       - Return `{ exportedAt, user, mailboxes, rules, patterns, events, auditLogs }`.
       - Use `.lean()` on all queries for memory efficiency.

    3. `DELETE /delete-data` -- Delete all user data and account.
       - Run parallel deletes: EmailEvent, Pattern, Rule, StagedEmail, AuditLog, Notification, WebhookSubscription, Mailbox (all by userId).
       - Then delete the User record: `User.findByIdAndDelete(userId)`.
       - Clear the session cookie: `res.clearCookie('msedb_session')`.
       - Return `{ message: 'All data deleted successfully' }`.
       - Import all required models: EmailEvent, Pattern, Rule, StagedEmail, AuditLog, Notification, WebhookSubscription, Mailbox, User.

    **Extend `backend/src/routes/admin.ts`:**

    1. `GET /analytics` -- Aggregate analytics.
       - Parallel queries: `User.countDocuments()`, `User.countDocuments({isActive:true})`, `EmailEvent.countDocuments()`, `Rule.countDocuments({isEnabled:true})`, `Pattern.countDocuments({status:{$in:['detected','suggested']}})`.
       - Import EmailEvent, Rule, Pattern models.
       - Return `{ totalUsers, activeUsers, totalEvents, totalRules, totalPatterns }`.

    2. `GET /health` -- System health detail.
       - Query WebhookSubscription: `.find().populate('mailboxId','email displayName').populate('userId','email displayName').select('subscriptionId status expiresAt lastNotificationAt errorCount mailboxId userId').lean()`.
       - Query Mailbox: `.find().populate('userId','email displayName').select('email isConnected encryptedTokens.expiresAt userId lastSyncAt').lean()`.
       - Map mailboxes to tokenHealth: `{ mailboxId, email, user, isConnected, tokenExpiresAt, tokenHealthy: isConnected && expiresAt > now, lastSyncAt }`.
       - Import WebhookSubscription, Mailbox models.
       - Return `{ subscriptions, tokenHealth }`.

    3. `POST /org-rules` -- Create org-wide rule.
       - Accept: `name` (required), `conditions` (required), `actions` (required array), `isEnabled` (default true), `priority` (default 0).
       - Validate name is non-empty string.
       - Create Rule with `scope: 'org'`, `userId: req.user!.userId`, `createdBy: req.user!.userId`, NO mailboxId.
       - Return 201 with created rule.

    4. `GET /org-rules` -- List org-wide rules.
       - `Rule.find({scope:'org'}).sort({priority:1}).lean()`.
       - Return array of org rules.

    5. `DELETE /org-rules/:id` -- Delete org-wide rule.
       - `Rule.findOneAndDelete({_id:params.id, scope:'org'})`.
       - Return 404 if not found.
       - Return `{ success: true }`.

    Route ordering: `/analytics`, `/health`, `/org-rules` (POST and GET) must be defined BEFORE any `/:id` routes if any exist. Currently admin has no `/:id` routes at the router root, so place these after existing routes.

    **Mount settings router in `backend/src/server.ts`:**
    - Import `settingsRouter` from `./routes/settings.js`.
    - Add `app.use('/api/settings', settingsRouter);` after the notifications router mount.
  </action>
  <verify>
    - `npx tsc --noEmit --project backend/tsconfig.json` passes (all routes and model changes compile).
    - Grep `settingsRouter` in `backend/src/server.ts` confirms it's mounted.
    - Grep `mailboxId.*required.*false` or absence of `required: true` on mailboxId in Rule.ts confirms the change.
    - Grep `/analytics` and `/health` and `/org-rules` in `backend/src/routes/admin.ts` confirms endpoints exist.
  </verify>
  <done>
    Settings routes handle GET (current settings), GET /export-data (downloadable JSON), DELETE /delete-data (full account deletion). User preferences route accepts all preference fields with field-level $set. Admin routes include analytics, system health, and org-wide rule CRUD. Rule model allows optional mailboxId for org-scoped rules. All routes mounted in server.ts.
  </done>
</task>

</tasks>

<verification>
- All backend TypeScript compiles: `npx tsc --noEmit --project backend/tsconfig.json`
- All 8 new shadcn components exist in `frontend/src/components/ui/`
- New routes mounted in server.ts: `/api/notifications`, `/api/settings`
- Admin routes extended with `/analytics`, `/health`, `/org-rules`
- NotificationService uses centralized Socket.IO emission pattern
- Rule.mailboxId is optional (no required constraint)
</verification>

<success_criteria>
- notificationService.createNotification() creates document + emits Socket.IO event
- GET /api/notifications returns paginated list with unread count
- GET /api/notifications/unread-count returns count
- PATCH /api/notifications/:id/read marks single as read
- PATCH /api/notifications/read-all marks all as read
- PATCH /api/user/preferences accepts workingHoursStart, workingHoursEnd, aggressiveness alongside automationPaused
- GET /api/settings returns user settings with mailbox connection status
- GET /api/settings/export-data returns downloadable JSON
- DELETE /api/settings/delete-data removes all user data
- GET /api/admin/analytics returns aggregate counts
- GET /api/admin/health returns subscription and token health
- POST/GET/DELETE /api/admin/org-rules manage org-wide rules
- 8 shadcn components installed for frontend plans
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-notifications-admin/07-01-SUMMARY.md`
</output>
