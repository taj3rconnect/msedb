---
phase: 01-infrastructure-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - 01-01
  - 01-02
files_modified:
  - backend/package.json
  - backend/src/utils/encryption.ts
  - backend/src/middleware/rateLimiter.ts
  - backend/src/middleware/errorHandler.ts
  - backend/src/middleware/security.ts
  - backend/src/routes/health.ts
  - backend/src/routes/webhooks.ts
  - backend/src/server.ts
autonomous: false
requirements:
  - INFR-02
  - INFR-04
  - INFR-05
user_setup:
  - service: cloudflare-tunnel
    why: "Public HTTPS endpoint for Microsoft Graph webhook delivery"
    env_vars:
      - name: GRAPH_WEBHOOK_URL
        source: "Cloudflare Tunnel hostname (e.g., https://msedb-api.yourdomain.com/webhooks/graph)"
    dashboard_config:
      - task: "Create Cloudflare Tunnel pointing to localhost:8010"
        location: "Cloudflare Zero Trust Dashboard -> Networks -> Tunnels"
      - task: "Disable Bot Fight Mode for zone (Free plan) OR create WAF Skip rule for /webhooks/graph (Pro plan)"
        location: "Cloudflare Dashboard -> Security -> Bots (Free) or WAF (Pro)"
must_haves:
  truths:
    - "AES-256-GCM encryption can encrypt and decrypt a test string round-trip"
    - "Rate limiting returns 429 after exceeding 5 requests/min on auth routes"
    - "Rate limiting returns 429 after exceeding 100 requests/min on API routes"
    - "Health endpoint at /api/health reports MongoDB and Redis status"
    - "Health endpoint returns 503 when a service is down"
    - "Cloudflare Tunnel forwards HTTPS traffic to the backend webhook endpoint"
    - "POST /webhooks/graph returns 202 within 3 seconds"
    - "All containers run as non-root users with security headers applied"
  artifacts:
    - path: "backend/src/utils/encryption.ts"
      provides: "AES-256-GCM encrypt/decrypt functions"
      exports: ["encrypt", "decrypt"]
      contains: "aes-256-gcm"
    - path: "backend/src/middleware/rateLimiter.ts"
      provides: "Rate limiters for auth (5/min) and API (100/min) routes"
      exports: ["authLimiter", "apiLimiter"]
      contains: "RedisStore"
    - path: "backend/src/routes/health.ts"
      provides: "Health check endpoint reporting all subsystem status"
      contains: "mongoose.connection.readyState"
    - path: "backend/src/middleware/errorHandler.ts"
      provides: "Global Express 5 error handler with structured logging"
      contains: "err.*req.*res.*next"
    - path: "backend/src/middleware/security.ts"
      provides: "Helmet, CORS, compression middleware bundle"
      contains: "helmet"
  key_links:
    - from: "backend/src/routes/health.ts"
      to: "backend/src/config/database.ts"
      via: "mongoose.connection.readyState check"
      pattern: "readyState"
    - from: "backend/src/routes/health.ts"
      to: "backend/src/config/redis.ts"
      via: "redis.ping() check"
      pattern: "redis.*ping"
    - from: "backend/src/middleware/rateLimiter.ts"
      to: "backend/src/config/redis.ts"
      via: "RedisStore using ioredis client"
      pattern: "RedisStore"
    - from: "backend/src/server.ts"
      to: "backend/src/middleware/rateLimiter.ts"
      via: "app.use for auth and API routes"
      pattern: "authLimiter|apiLimiter"
---

<objective>
Add security hardening (AES-256-GCM encryption, rate limiting, security headers, error handling), a comprehensive health endpoint, and configure Cloudflare Tunnel for webhook ingress.

Purpose: Complete the infrastructure foundation with production-grade security and observability. The encryption module is needed by Phase 2 for token storage. The health endpoint enables Docker healthchecks and monitoring. The Cloudflare Tunnel is required by Phase 3 for Graph API webhook subscriptions.

Output: Security-hardened backend with rate limiting, encryption utilities, comprehensive health checks, and a publicly accessible webhook endpoint via Cloudflare Tunnel.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md
@.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: AES-256-GCM encryption, rate limiting, security middleware, error handler, and health endpoint</name>
  <files>
    backend/package.json
    backend/src/utils/encryption.ts
    backend/src/middleware/rateLimiter.ts
    backend/src/middleware/errorHandler.ts
    backend/src/middleware/security.ts
    backend/src/routes/health.ts
    backend/src/routes/webhooks.ts
    backend/src/server.ts
  </files>
  <action>
    First, add rate limiting dependencies:
    ```
    cd backend && npm install express-rate-limit@7 rate-limit-redis@4
    ```

    **backend/src/utils/encryption.ts**:
    - Import crypto from 'node:crypto'
    - Constants: ALGORITHM = 'aes-256-gcm', IV_LENGTH = 12, TAG_LENGTH = 16
    - Export interface EncryptedData { encrypted: string; iv: string; tag: string }
    - Export `encrypt(text: string, keyHex: string): EncryptedData`:
      - Derive key with Buffer.from(keyHex, 'hex')
      - Generate random IV with crypto.randomBytes(IV_LENGTH)
      - Create cipher with createCipheriv(ALGORITHM, key, iv)
      - Update + final, get auth tag
      - Return { encrypted, iv, tag } all as hex strings
    - Export `decrypt(encrypted: string, ivHex: string, tagHex: string, keyHex: string): string`:
      - Derive key, iv, tag from hex
      - Create decipher with createDecipheriv, setAuthTag
      - Update + final, return decrypted string
    - See research Pattern 3 for implementation reference. Use Buffer.from() not new Buffer().

    **backend/src/middleware/rateLimiter.ts**:
    - Import rateLimit from 'express-rate-limit'
    - Import { RedisStore } from 'rate-limit-redis'
    - Import getRedisClient from config/redis.ts
    - Export `createAuthLimiter()`: returns rateLimit with windowMs 60000 (1 min), limit 5, standardHeaders true, legacyHeaders false, RedisStore with prefix 'rl:auth:', sendCommand using redisClient.call()
    - Export `createApiLimiter()`: same but limit 100, prefix 'rl:api:'
    - Use factory functions (not direct exports) because Redis client may not be available at import time
    - See research Pattern 5 for implementation reference

    **backend/src/middleware/errorHandler.ts**:
    - Export Express 5 global error handler: `(err: Error, req: Request, res: Response, next: NextFunction) => void`
    - Log error with logger (include stack trace, request method, path, user ID if available)
    - Return structured JSON error: { error: { message, status, timestamp } }
    - In development: include stack trace in response
    - In production: generic message for 500 errors (do not leak internal details)
    - Handle specific error types: ValidationError (400), UnauthorizedError (401), ForbiddenError (403), NotFoundError (404)

    **backend/src/middleware/security.ts**:
    - Import helmet, cors, compression
    - Export `configureSecurityMiddleware(app: Express)`:
      - Apply helmet() with sensible defaults
      - Apply cors({ origin: config.appUrl, credentials: true, methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'], allowedHeaders: ['Content-Type', 'Authorization'] })
      - Apply compression()
      - Apply express.json({ limit: '1mb' })
      - Apply express.urlencoded({ extended: true, limit: '1mb' })

    **backend/src/routes/health.ts**:
    - Export Express Router
    - GET /api/health:
      - Check MongoDB: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected'
      - Check Redis: try redis.ping(), 'connected' or 'error'
      - Check BullMQ: import queues, check if queues object exists (basic check for now -- detailed worker status is future)
      - Compute overall healthy: all services connected
      - Return status 200 if healthy, 503 if degraded
      - Response body: { status: 'healthy'|'degraded', uptime: process.uptime(), timestamp: ISO string, version: package.json version or '1.0.0', services: { mongodb: status, redis: status }, queues: { count: number of active queues } }
    - This replaces the placeholder /api/health from Plan 01

    **backend/src/routes/webhooks.ts**:
    - Export Express Router
    - POST /webhooks/graph:
      - Handle Graph API webhook validation: if query param 'validationToken' exists, return it as text/plain with 200 (Graph subscription validation handshake)
      - For actual notifications: log the notification, return 202 with { status: 'accepted' }
      - This is a placeholder -- real processing comes in Phase 3
      - CRITICAL: Must respond within 3 seconds. No blocking operations.

    **Update backend/src/server.ts**:
    - Remove the inline helmet/cors/compression imports -- use configureSecurityMiddleware instead
    - Remove the inline /api/health and /webhooks/graph handlers -- use routers
    - Apply security middleware via configureSecurityMiddleware(app)
    - Apply rate limiters: createAuthLimiter() on '/auth' routes, createApiLimiter() on '/api' routes
    - Mount health router (no rate limiting on health endpoint)
    - Mount webhooks router (no rate limiting on webhook endpoint -- Microsoft controls the rate)
    - Apply error handler as last middleware
    - Keep the existing startup sequence (connectDatabase, Redis, initializeSchedulers, listen)

    Rebuild and verify:
    - `docker compose up --build -d`
    - Test health endpoint
    - Test rate limiting (send 6 rapid requests to see 429)
    - Test encryption round-trip (in logs or via a test)
  </action>
  <verify>
    1. `docker compose up --build -d` builds and starts successfully
    2. `curl -s http://localhost:8010/api/health | jq .` shows MongoDB "connected" and Redis "connected"
    3. Rate limit test: `for i in {1..7}; do curl -s -o /dev/null -w "%{http_code}\n" http://localhost:8010/api/health; done` -- first requests return 200 (health is NOT rate limited)
    4. Rate limit on auth stub: create a quick test or verify rate limiter middleware is mounted
    5. `curl -s -X POST "http://localhost:8010/webhooks/graph?validationToken=test123"` returns "test123" as text/plain
    6. `curl -s -X POST http://localhost:8010/webhooks/graph -H "Content-Type: application/json" -d '{"value":[]}' | jq .` returns { status: "accepted" } with 202
    7. `docker compose logs msedb-backend | grep -i "helmet\|security"` confirms security middleware loaded
    8. Backend TypeScript compiles: `cd backend && npx tsc --noEmit`
  </verify>
  <done>
    AES-256-GCM encryption encrypt/decrypt functions work with round-trip verification. Rate limiting enforced: 5/min on auth, 100/min on API routes, backed by Redis store. Health endpoint reports MongoDB and Redis status with 200/503 based on service health. Webhook endpoint handles Graph validation handshake and returns 202 for notifications. Security headers applied via helmet. CORS configured for frontend origin. Global error handler catches and logs all errors with structured responses.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Cloudflare Tunnel and end-to-end infrastructure</name>
  <files>none (verification only)</files>
  <action>
    Run automated verification checks, then request human verification for Cloudflare Tunnel.

    **Automated checks (Claude runs these):**
    1. `docker compose ps` -- all 4 containers healthy
    2. `curl http://localhost:8010/api/health` -- returns healthy with all services connected
    3. `curl -X POST "http://localhost:8010/webhooks/graph?validationToken=hello"` -- returns "hello"
    4. `docker compose exec msedb-redis redis-cli CONFIG GET maxmemory-policy` -- returns noeviction
    5. `docker compose exec msedb-redis redis-cli KEYS "bull:*" | head -10` -- shows BullMQ keys

    **Human verification needed for Cloudflare Tunnel:**
    1. Confirm Cloudflare Tunnel is configured and running (cloudflared service or connector)
    2. Set GRAPH_WEBHOOK_URL in .env to the tunnel hostname (e.g., https://msedb-api.yourdomain.com/webhooks/graph)
    3. Test webhook endpoint through tunnel: `curl -X POST https://msedb-api.yourdomain.com/webhooks/graph?validationToken=tunnel-test` should return "tunnel-test"
    4. Confirm Bot Fight Mode is disabled (Free plan) or WAF Skip rule exists for /webhooks/graph (Pro plan)
    5. Visit https://msedb-api.yourdomain.com/api/health in browser to confirm tunnel is forwarding

    If Cloudflare Tunnel is not yet configured, note it as a blocker for Phase 3 but the rest of infrastructure is complete.
  </action>
  <verify>
    All automated checks pass. Human confirms Cloudflare Tunnel status (operational or deferred).
  </verify>
  <done>
    All infrastructure components verified: 4 healthy containers, MongoDB with models, Redis with BullMQ, security hardening, health endpoint, webhook endpoint. Cloudflare Tunnel status confirmed by human (operational or documented as deferred blocker for Phase 3).
  </done>
</task>

</tasks>

<verification>
1. AES-256-GCM encrypt then decrypt produces original text
2. Rate limiting returns 429 when limits exceeded
3. /api/health returns 200 with MongoDB/Redis connected, 503 when service down
4. /webhooks/graph handles validation handshake (returns validationToken)
5. /webhooks/graph returns 202 for POST notifications
6. Security headers present in responses (check with curl -I)
7. Cloudflare Tunnel forwards HTTPS to backend (human-verified)
8. Bot protection configured for webhook path (human-verified)
</verification>

<success_criteria>
- AES-256-GCM encryption module ready for token storage in Phase 2
- Rate limiting active: 5/min auth, 100/min API, backed by Redis
- Health endpoint reports MongoDB, Redis, uptime, and queue status
- Webhook endpoint handles Graph API validation and returns 202
- Security headers (helmet), CORS, compression, and error handling configured
- Cloudflare Tunnel operational for webhook ingress (or documented as deferred blocker)
- Full infrastructure stack passes all Phase 1 success criteria
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-03-SUMMARY.md`
</output>
