---
phase: 01-infrastructure-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - .env.example
  - .gitignore
  - .dockerignore
  - backend/Dockerfile
  - backend/.dockerignore
  - backend/package.json
  - backend/tsconfig.json
  - backend/src/server.ts
  - backend/src/config/index.ts
  - backend/src/config/logger.ts
  - frontend/Dockerfile
  - frontend/.dockerignore
  - frontend/nginx.conf
  - frontend/package.json
  - frontend/tsconfig.json
  - frontend/tsconfig.app.json
  - frontend/tsconfig.node.json
  - frontend/vite.config.ts
  - frontend/index.html
  - frontend/src/main.tsx
  - frontend/src/App.tsx
  - frontend/src/app.css
autonomous: true
requirements:
  - INFR-01
must_haves:
  truths:
    - "docker compose up builds all four containers (backend, frontend, MongoDB, Redis) without errors"
    - "All four containers report healthy status via Docker healthchecks"
    - "Backend responds on port 8010 with a basic JSON response"
    - "Frontend loads on port 3010 and displays a React page through nginx"
    - "Resource limits are enforced (5 CPU / 5GB RAM total across 4 containers)"
    - "All containers run as non-root users"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Service definitions for all 4 containers with resource limits, healthchecks, volumes, networking"
      contains: "msedb-backend"
    - path: "backend/Dockerfile"
      provides: "Multi-stage Node.js 22 build with tini and non-root user"
      contains: "node:22-alpine"
    - path: "backend/src/server.ts"
      provides: "Express 5 application entry point"
      contains: "express"
    - path: "frontend/Dockerfile"
      provides: "Multi-stage Vite build to nginx-unprivileged with non-root"
      contains: "nginxinc/nginx-unprivileged"
    - path: "frontend/src/App.tsx"
      provides: "Minimal React 19 shell"
      contains: "function App"
  key_links:
    - from: "docker-compose.yml"
      to: "backend/Dockerfile"
      via: "build context"
      pattern: "context: ./backend"
    - from: "docker-compose.yml"
      to: "frontend/Dockerfile"
      via: "build context"
      pattern: "context: ./frontend"
    - from: "frontend/nginx.conf"
      to: "backend"
      via: "proxy_pass for /api and /webhooks"
      pattern: "proxy_pass.*8010"
---

<objective>
Scaffold the entire MSEDB project: Docker Compose stack with four containers (backend, frontend, MongoDB, Redis), multi-stage Dockerfiles, Express 5 backend skeleton, React 19 + Vite + Tailwind 4 frontend shell, and all configuration files.

Purpose: Establish the containerized runtime foundation that all subsequent phases build upon. Nothing else can be built until `docker compose up` produces four healthy containers.

Output: A working Docker Compose stack where `docker compose up --build` starts all services, the backend responds on :8010, and the frontend loads on :3010.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project scaffolding, Docker Compose, and Dockerfiles</name>
  <files>
    docker-compose.yml
    .env.example
    .gitignore
    .dockerignore
    backend/Dockerfile
    backend/.dockerignore
    backend/package.json
    backend/tsconfig.json
    frontend/Dockerfile
    frontend/.dockerignore
    frontend/nginx.conf
    frontend/package.json
    frontend/tsconfig.json
    frontend/tsconfig.app.json
    frontend/tsconfig.node.json
    frontend/vite.config.ts
    frontend/index.html
  </files>
  <action>
    Create the full project scaffolding for MSEDB:

    **docker-compose.yml** (NO version field -- it is obsolete):
    - `msedb-backend`: build from `./backend`, port 8010:8010, env_file .env, depends_on mongo+redis (condition: service_healthy), network msedb-network, volume msedb-logs:/app/logs, restart unless-stopped, deploy limits cpus 2.0 memory 2G, healthcheck using wget to http://localhost:8010/api/health (interval 30s, timeout 5s, retries 3, start_period 30s)
    - `msedb-frontend`: build from `./frontend`, port 3010:8080, depends_on backend (condition: service_healthy), network msedb-network, restart unless-stopped, deploy limits cpus 0.5 memory 512M, healthcheck using wget to http://localhost:8080 (interval 30s, timeout 5s, retries 3)
    - `msedb-mongo`: image mongo:7, port 27020:27017, volume msedb-mongo-data:/data/db, network, restart, deploy limits cpus 2.0 memory 2G, command `mongod --bind_ip_all`, healthcheck with mongosh eval db.adminCommand('ping') (interval 10s, timeout 5s, retries 5, start_period 20s)
    - `msedb-redis`: image redis:7-alpine, port 6382:6379, volume msedb-redis-data:/data, network, restart, deploy limits cpus 0.5 memory 512M, command `redis-server --appendonly yes --maxmemory 384mb --maxmemory-policy noeviction`, healthcheck redis-cli ping (interval 10s, timeout 5s, retries 5)
    - Networks: msedb-network (bridge, name: msedb-network)
    - Volumes: msedb-mongo-data, msedb-redis-data, msedb-logs (all named)

    **backend/Dockerfile** (multi-stage, non-root, tini):
    - Stage 1 (builder): FROM node:22-alpine, WORKDIR /app, COPY package*.json, RUN npm ci, COPY . ., RUN npm run build
    - Stage 2 (runtime): FROM node:22-alpine, RUN apk add --no-cache tini wget, create appgroup (1001) and appuser (1001), WORKDIR /app, COPY --chown from builder: dist, node_modules, package.json, create /app/logs owned by appuser, USER appuser, EXPOSE 8010, ENTRYPOINT tini, CMD node dist/server.js

    **frontend/Dockerfile** (multi-stage, Vite -> nginx-unprivileged):
    - Stage 1 (builder): FROM node:22-alpine, WORKDIR /app, COPY package*.json, RUN npm ci, COPY . ., RUN npm run build
    - Stage 2 (runtime): FROM nginxinc/nginx-unprivileged:alpine, COPY --from=builder /app/dist to /usr/share/nginx/html, COPY nginx.conf to /etc/nginx/conf.d/default.conf, EXPOSE 8080, CMD nginx -g daemon off
    - Note: nginxinc/nginx-unprivileged runs as non-root (uid 101) by default. No USER directive or apk add needed -- wget is not available but the Docker healthcheck in docker-compose.yml uses wget from the base image's busybox.

    **frontend/nginx.conf**:
    - Listen on port 8080 (nginx-unprivileged runs as non-root, cannot bind to ports below 1024)
    - Serve /usr/share/nginx/html with try_files for SPA routing (try_files $uri $uri/ /index.html)
    - Proxy /api/ to http://msedb-backend:8010/api/
    - Proxy /webhooks/ to http://msedb-backend:8010/webhooks/
    - Proxy /auth/ to http://msedb-backend:8010/auth/
    - Gzip on for text/html, application/json, text/css, application/javascript

    **backend/package.json**:
    - name: msedb-backend, private: true
    - scripts: build (tsc), start (node dist/server.js), dev (tsx watch src/server.ts)
    - dependencies: express@5, dotenv, winston, cors, helmet, compression
    - devDependencies: typescript, @types/express, @types/node, @types/cors, @types/compression, tsx
    - Note: mongoose, bullmq, ioredis, express-rate-limit, rate-limit-redis will be added in Plan 02

    **backend/tsconfig.json**:
    - target ES2022, module NodeNext, moduleResolution NodeNext, outDir dist, rootDir src, strict true, esModuleInterop true, skipLibCheck true, forceConsistentCasingInFileNames true, resolveJsonModule true, declaration true, declarationMap true, sourceMap true

    **frontend/package.json**: Initialize with `npm create vite@latest` template for react-ts, then add @tailwindcss/vite as a dependency. Include React 19, react-dom 19.

    **frontend/vite.config.ts**: Import tailwindcss from @tailwindcss/vite, add as plugin. Set server.port to 5173 for dev.

    **frontend/tsconfig.json**, **frontend/tsconfig.app.json**, **frontend/tsconfig.node.json**: Standard Vite React TypeScript configs with strict mode.

    **frontend/index.html**: Standard Vite entry point linking to /src/main.tsx.

    **.env.example**: Template with all required env vars:
    - NODE_ENV=development
    - PORT=8010
    - MONGODB_URI=mongodb://msedb-mongo:27017/msedb
    - REDIS_HOST=msedb-redis
    - REDIS_PORT=6379
    - LOG_LEVEL=info
    - ENCRYPTION_KEY=(generate with: openssl rand -hex 32)
    - JWT_SECRET=(generate with: openssl rand -hex 64)
    - SESSION_SECRET=(generate with: openssl rand -hex 32)
    - AZURE_AD_TENANT_ID=
    - AZURE_AD_CLIENT_ID=
    - AZURE_AD_CLIENT_SECRET=
    - APP_URL=http://localhost:3010
    - API_URL=http://localhost:8010
    - GRAPH_WEBHOOK_URL=
    - ADMIN_EMAIL=

    **.gitignore**: node_modules, dist, .env, *.log, .DS_Store, logs/

    **.dockerignore** (root): node_modules, dist, .env, .git, *.md (except README)

    **backend/.dockerignore**: node_modules, dist, .env, *.log, .git

    **frontend/.dockerignore**: node_modules, dist, .env, *.log, .git
  </action>
  <verify>
    Run `ls -la docker-compose.yml backend/Dockerfile backend/package.json backend/tsconfig.json frontend/Dockerfile frontend/package.json frontend/nginx.conf .env.example` to confirm all files exist.
    Validate docker-compose.yml syntax: `docker compose config --quiet` (should produce no errors).
  </verify>
  <done>
    All scaffolding files exist. docker-compose.yml passes syntax validation. Both Dockerfiles use multi-stage builds with non-root users. Resource limits total 5 CPU / 5GB RAM. Redis uses noeviction policy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backend Express 5 skeleton and frontend React 19 shell</name>
  <files>
    backend/src/server.ts
    backend/src/config/index.ts
    backend/src/config/logger.ts
    frontend/src/main.tsx
    frontend/src/App.tsx
    frontend/src/app.css
  </files>
  <action>
    Create the minimal application code for both backend and frontend:

    **backend/src/config/index.ts**:
    - Load dotenv (import 'dotenv/config' at top)
    - Export a config object with typed fields: port (number, default 8010), nodeEnv, mongodbUri, redisHost, redisPort, logLevel, encryptionKey, jwtSecret, sessionSecret, azureAdTenantId, azureAdClientId, azureAdClientSecret, appUrl, apiUrl, graphWebhookUrl, adminEmail
    - All values from process.env with sensible defaults where appropriate

    **backend/src/config/logger.ts**:
    - Create Winston logger per research Pattern (see research)
    - JSON format in production, colorize+simple in development
    - Console transport always, File transports for error.log and combined.log (maxsize 10MB, maxFiles 5/10)
    - defaultMeta: { service: 'msedb-backend' }
    - Export as default

    **backend/src/server.ts**:
    - Import express (Express 5 -- `import express from 'express'`)
    - Import helmet, cors, compression
    - Import config and logger
    - Create Express app
    - Apply helmet(), cors({ origin: config.appUrl, credentials: true }), compression(), express.json()
    - Add a temporary GET /api/health that returns { status: 'healthy', uptime: process.uptime(), timestamp: new Date().toISOString() } -- this is a placeholder; the real health endpoint comes in Plan 03
    - Add a temporary POST /webhooks/graph that returns 202 with { status: 'accepted' } -- placeholder for future webhook handler
    - Add a global error handler: `app.use((err, req, res, next) => ...)` that logs and returns 500 -- Express 5 style (async errors auto-propagate)
    - Start listening on config.port, log startup message with logger

    **frontend/src/app.css**:
    - `@import "tailwindcss";` (Tailwind 4 CSS-first config -- this single import replaces the old @tailwind directives)

    **frontend/src/main.tsx**:
    - Standard React 19 entry: createRoot, render App in StrictMode
    - Import './app.css'

    **frontend/src/App.tsx**:
    - Minimal shell component displaying "MSEDB" heading and "Infrastructure running" status text
    - Simple centered layout using Tailwind utility classes

    After creating all source files, install dependencies:
    - `cd backend && npm install` to generate package-lock.json
    - `cd frontend && npm install` to generate package-lock.json
    - Copy .env.example to .env with generated secrets (openssl rand -hex 32 for ENCRYPTION_KEY, openssl rand -hex 64 for JWT_SECRET, openssl rand -hex 32 for SESSION_SECRET)

    Then build and start the Docker Compose stack:
    - `docker compose up --build -d`
    - Wait for all containers to be healthy
    - Verify backend responds: `curl -s http://localhost:8010/api/health`
    - Verify frontend loads: `curl -s http://localhost:3010 | head -20`
  </action>
  <verify>
    1. `docker compose ps` shows all 4 containers as "healthy"
    2. `curl -s http://localhost:8010/api/health` returns JSON with status "healthy"
    3. `curl -s http://localhost:3010` returns HTML containing "MSEDB"
    4. `docker stats --no-stream` shows memory limits are enforced on containers
    5. `docker compose exec msedb-backend whoami` returns "appuser" (non-root)
    6. `docker compose exec msedb-frontend whoami` returns "nginx" (non-root, uid 101 from nginxinc/nginx-unprivileged)
    7. `docker compose exec msedb-redis redis-cli CONFIG GET maxmemory-policy` returns "noeviction"
  </verify>
  <done>
    All four containers (backend, frontend, MongoDB, Redis) start healthy via `docker compose up`. Backend serves /api/health on port 8010. Frontend serves React app on port 3010. Containers run as non-root. Redis uses noeviction policy. Resource limits enforced.
  </done>
</task>

</tasks>

<verification>
1. `docker compose up --build -d` completes without build errors
2. `docker compose ps` shows all 4 containers with "healthy" status
3. `curl http://localhost:8010/api/health` returns 200 with JSON health response
4. `curl http://localhost:3010` returns HTML page with React app
5. `docker stats --no-stream` shows memory/CPU limits on all containers
6. `docker compose exec msedb-backend whoami` returns non-root user
7. `docker compose exec msedb-redis redis-cli CONFIG GET maxmemory-policy` returns "noeviction"
</verification>

<success_criteria>
- Four Docker containers (msedb-backend, msedb-frontend, msedb-mongo, msedb-redis) all report healthy
- Backend Express 5 server responds on port 8010
- Frontend React 19 + Tailwind 4 app loads on port 3010
- Resource limits total 5 CPU / 5GB RAM across all containers
- All containers run as non-root users
- Redis uses noeviction memory policy
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md`
</output>
