---
phase: 03-email-observation-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/graphClient.ts
  - backend/src/services/subscriptionService.ts
  - backend/src/routes/webhooks.ts
  - backend/src/jobs/queues.ts
  - backend/src/jobs/processors/webhookRenewal.ts
  - backend/src/config/index.ts
autonomous: false
requirements: [OBSV-01, OBSV-04]

must_haves:
  truths:
    - "Graph API calls use Bearer token injection and return structured errors"
    - "Webhook handler validates clientState, enqueues notifications into BullMQ, and returns 202 within milliseconds"
    - "Lifecycle notifications (subscriptionRemoved, missed, reauthorizationRequired) are routed to webhook-renewal queue"
    - "Webhook subscriptions are created per mailbox with lifecycleNotificationUrl and 2-hour expiry"
    - "Webhook renewal processor recreates expired or removed subscriptions and runs on startup"
    - "Cloudflare Tunnel forwards HTTPS to backend webhook endpoint"
  artifacts:
    - path: "backend/src/services/graphClient.ts"
      provides: "Graph API fetch wrapper with token injection and GraphApiError"
      exports: ["graphFetch", "GraphApiError", "GRAPH_BASE"]
    - path: "backend/src/services/subscriptionService.ts"
      provides: "Subscription CRUD: create, renew, delete, sync from Graph"
      exports: ["createSubscription", "renewSubscription", "deleteSubscription", "syncSubscriptionsOnStartup"]
    - path: "backend/src/routes/webhooks.ts"
      provides: "Enhanced webhook handler with clientState validation and BullMQ enqueue"
    - path: "backend/src/jobs/queues.ts"
      provides: "webhook-events queue added to QUEUE_NAMES and queues record"
    - path: "backend/src/jobs/processors/webhookRenewal.ts"
      provides: "BullMQ processor for subscription renewal and lifecycle event handling"
      exports: ["processWebhookRenewal"]
  key_links:
    - from: "backend/src/routes/webhooks.ts"
      to: "backend/src/jobs/queues.ts"
      via: "queues['webhook-events'].add() and queues['webhook-renewal'].add()"
      pattern: "queues\\['webhook-events'\\]\\.add|queues\\['webhook-renewal'\\]\\.add"
    - from: "backend/src/jobs/processors/webhookRenewal.ts"
      to: "backend/src/services/subscriptionService.ts"
      via: "createSubscription/renewSubscription calls"
      pattern: "createSubscription|renewSubscription|syncSubscriptionsOnStartup"
    - from: "backend/src/services/graphClient.ts"
      to: "https://graph.microsoft.com/v1.0"
      via: "native fetch with Bearer token"
      pattern: "graph\\.microsoft\\.com"
    - from: "backend/src/services/subscriptionService.ts"
      to: "backend/src/auth/tokenManager.ts"
      via: "getAccessTokenForMailbox"
      pattern: "getAccessTokenForMailbox"
---

<objective>
Build the Graph API client, enhance the webhook handler to validate and enqueue notifications via BullMQ, implement the subscription service for creating and renewing webhook subscriptions per mailbox, and wire the webhook-renewal BullMQ processor.

Purpose: This is the ingress layer of the observation pipeline -- without it, no email events can arrive from Microsoft Graph. The webhook handler must return 202 immediately (zero blocking), and subscriptions must auto-renew to prevent silent data loss.

Output: graphClient.ts, subscriptionService.ts, enhanced webhooks.ts, webhook-events queue, webhookRenewal.ts processor
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-email-observation-pipeline/03-RESEARCH.md

@backend/src/config/index.ts
@backend/src/config/redis.ts
@backend/src/routes/webhooks.ts
@backend/src/jobs/queues.ts
@backend/src/jobs/schedulers.ts
@backend/src/jobs/processors/tokenRefresh.ts
@backend/src/auth/tokenManager.ts
@backend/src/utils/graph.ts
@backend/src/models/WebhookSubscription.ts
@backend/src/models/Mailbox.ts
@backend/src/middleware/errorHandler.ts
@backend/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Graph API client, webhook-events queue, and webhook handler enhancement</name>
  <files>
    backend/src/services/graphClient.ts
    backend/src/routes/webhooks.ts
    backend/src/jobs/queues.ts
  </files>
  <action>
    **1. Create `backend/src/services/graphClient.ts`:**

    A thin wrapper around native `fetch()` for all Graph API v1.0 calls. No SDK.

    - Export `GRAPH_BASE = 'https://graph.microsoft.com/v1.0'`
    - Create `GraphApiError` class extending Error with `status: number`, `body: string`, `path: string` fields. Do NOT extend AppError -- this is a Graph-specific error used internally, not for HTTP responses
    - Export `async function graphFetch(path: string, accessToken: string, options?: RequestInit): Promise<Response>`:
      - If `path` starts with `http` (e.g., nextLink/deltaLink URLs), use it as-is; otherwise prepend `GRAPH_BASE`
      - Set headers: `Authorization: Bearer ${accessToken}`, `Content-Type: application/json`, merge with options.headers
      - On non-ok response: read response.text(), throw `GraphApiError(response.status, body, path)`
      - Return the Response object on success
    - Keep it simple: no retry logic here (BullMQ handles retries at the job level)

    **2. Add `webhook-events` queue to `backend/src/jobs/queues.ts`:**

    Following the existing pattern exactly:
    - Add `'webhook-events'` to the `QUEUE_NAMES` const array (position it before `'webhook-renewal'`)
    - Add `'webhook-events': new Queue(...)` to the `queues` record with same connection/defaultJobOptions
    - Add `'webhook-events': createProcessor('webhook-events')` to `processorMap` (placeholder for now -- Plan 02 wires the real processor)
    - Update the worker creation to include the new queue (it already does via QUEUE_NAMES map)

    **3. Enhance `backend/src/routes/webhooks.ts`:**

    Upgrade the existing skeleton to validate and enqueue. Keep the validation handshake unchanged.

    - Import `{ queues }` from `'../jobs/queues.js'`
    - Import `{ WebhookSubscription }` from `'../models/WebhookSubscription.js'`
    - After the existing validation handshake block, for actual notifications:
      - Return `res.status(202).json({ status: 'accepted' })` IMMEDIATELY (before any async work)
      - After response is sent (use `res.on('finish', async () => { ... })` or simply do the enqueue after res.json -- Express allows async work after response), iterate over `req.body?.value ?? []`
      - For each notification:
        - Look up the subscription by `notification.subscriptionId` from the in-memory or DB cache. For now, find the WebhookSubscription document where `subscriptionId === notification.subscriptionId` and check `clientState === notification.clientState`. Use a try/catch -- if lookup fails, log and skip (do NOT block the response)
        - IMPORTANT: The response has already been sent. The clientState validation and enqueue happen AFTER the 202. If clientState does not match, log a warning and skip that notification
        - If it is a lifecycle notification (`notification.lifecycleEvent` exists), enqueue to `queues['webhook-renewal'].add('lifecycle-event', { notification, subscriptionId: notification.subscriptionId })`
        - Otherwise, enqueue to `queues['webhook-events'].add('change-notification', { notification, subscriptionId: notification.subscriptionId })`
      - Wrap the entire post-response block in try/catch -- log errors but never throw (response already sent)
    - CRITICAL: The enqueue operations happen AFTER `res.status(202).json(...)`. The response is the first thing sent. No await before the response.

    Actually, a cleaner pattern: send the response, then do async work without awaiting in the request handler. Use an async IIFE or `.catch()` to prevent unhandled rejections:

    ```typescript
    res.status(202).json({ status: 'accepted' });

    // Fire-and-forget: enqueue notifications after response is sent
    const notifications = req.body?.value ?? [];
    (async () => {
      for (const notification of notifications) {
        try {
          // validate clientState, then enqueue
        } catch (err) {
          logger.error('Failed to enqueue notification', { ... });
        }
      }
    })().catch((err) => {
      logger.error('Notification enqueue batch failed', { error: err.message });
    });
    ```
  </action>
  <verify>
    1. `cd /home/admin/claude/MSEDB && docker compose exec backend npx tsc --noEmit` passes
    2. graphClient.ts exports graphFetch, GraphApiError, GRAPH_BASE
    3. queues.ts has 6 queues (webhook-events added)
    4. webhooks.ts sends 202 before any async operations
  </verify>
  <done>
    Graph API client ready for all Phase 3 services. Webhook handler validates clientState and enqueues change/lifecycle notifications into separate BullMQ queues after immediately returning 202. webhook-events queue exists with placeholder processor.
  </done>
</task>

<task type="auto">
  <name>Task 2: Subscription service and webhook-renewal processor</name>
  <files>
    backend/src/services/subscriptionService.ts
    backend/src/jobs/processors/webhookRenewal.ts
    backend/src/jobs/queues.ts
    backend/src/server.ts
    backend/src/config/index.ts
  </files>
  <action>
    **1. Create `backend/src/services/subscriptionService.ts`:**

    Manages the full lifecycle of Graph webhook subscriptions per mailbox.

    - Import `graphFetch`, `GraphApiError` from `./graphClient.js`
    - Import `getAccessTokenForMailbox` from `../auth/tokenManager.js`
    - Import `WebhookSubscription` from `../models/WebhookSubscription.js`
    - Import `Mailbox` from `../models/Mailbox.js`
    - Import `config` from `../config/index.js`
    - Import `{ v4 as uuidv4 }` from `'uuid'`
    - Import `logger` from `../config/logger.js`

    Export the following functions:

    **`createSubscription(mailboxId: string)`:**
    - Get access token via `getAccessTokenForMailbox(mailboxId)`
    - Find the Mailbox document to get `email` (for the resource path)
    - Build the subscription body:
      - `changeType`: `'created,updated,deleted'`
      - `notificationUrl`: `${config.graphWebhookUrl}/webhooks/graph`
      - `lifecycleNotificationUrl`: `${config.graphWebhookUrl}/webhooks/graph`
      - `resource`: `users/${mailbox.email}/messages` (use email, not `me/` -- background jobs have no user context per Pitfall 5)
      - `expirationDateTime`: `new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString()` (2 hours)
      - `clientState`: `uuidv4()` (max 128 chars, UUID is 36)
    - POST to `/subscriptions` via graphFetch
    - Parse the response JSON
    - Create a WebhookSubscription document in MongoDB with all fields from the response + local fields (userId from Mailbox, mailboxId, clientState, status: 'active')
    - Return the created WebhookSubscription document
    - Log success with subscriptionId and mailboxId

    **`renewSubscription(subscriptionId: string)`:**
    - Find the WebhookSubscription document by subscriptionId
    - Get access token for the mailbox
    - PATCH `/subscriptions/${subscriptionId}` with new `expirationDateTime` (2 hours from now)
    - Update the MongoDB document with new expiresAt
    - Return the updated document

    **`deleteSubscription(subscriptionId: string)`:**
    - DELETE `/subscriptions/${subscriptionId}` via graphFetch
    - Remove or mark the WebhookSubscription document as expired
    - Catch 404 errors silently (subscription already gone)

    **`syncSubscriptionsOnStartup()`:**
    - Find all connected mailboxes
    - For each mailbox:
      - Find existing WebhookSubscription documents for this mailbox
      - If no subscription exists OR the existing subscription is expired (expiresAt < now), create a new one
      - If a subscription exists and is not expired, try to renew it. On failure (404 = subscription removed by Graph), delete the local record and create a new one
    - This runs on server startup to ensure all mailboxes have active subscriptions
    - Log summary: created, renewed, failed counts

    **`handleLifecycleEvent(event: { lifecycleEvent: string; subscriptionId: string })`:**
    - `subscriptionRemoved`: Delete local WebhookSubscription, find the mailbox, create a new subscription. Then trigger an immediate delta sync by adding a job to the delta-sync queue: `queues['delta-sync'].add('lifecycle-delta-sync', { mailboxId })`
    - `missed`: Trigger immediate delta sync for the affected mailbox (same as above). The delta sync will catch any missed events.
    - `reauthorizationRequired`: Try to renew the subscription. If that fails, delete and recreate.
    - Log each lifecycle event with subscriptionId and action taken

    **2. Create `backend/src/jobs/processors/webhookRenewal.ts`:**

    BullMQ processor following the existing tokenRefresh.ts pattern.

    - Export `async function processWebhookRenewal(job: Job): Promise<void>`
    - Handle two job types based on `job.name`:
      - `'renew-webhooks'` (scheduled every 2h): Call `syncSubscriptionsOnStartup()` -- it handles both startup and periodic renewal. Same logic applies: check all mailboxes, renew or recreate as needed.
      - `'lifecycle-event'` (enqueued by webhook handler): Extract `notification` from `job.data`, call `handleLifecycleEvent(notification)`
    - Log job start, type, and completion with counts

    **3. Update `backend/src/jobs/queues.ts`:**

    Wire the real webhook-renewal processor:
    - Import `{ processWebhookRenewal }` from `'./processors/webhookRenewal.js'`
    - Replace the placeholder processor for `'webhook-renewal'` with `processWebhookRenewal` in the processorMap

    **4. Update `backend/src/server.ts`:**

    Call `syncSubscriptionsOnStartup()` during server startup:
    - Import `{ syncSubscriptionsOnStartup }` from `'./services/subscriptionService.js'`
    - After `initializeSchedulers()` and before `app.listen()`, call `await syncSubscriptionsOnStartup()`
    - Wrap in try/catch -- log error but do NOT prevent server start if subscription sync fails (the periodic renewal will retry)

    **5. Add GRAPH_WEBHOOK_URL validation to `backend/src/config/index.ts`:**

    The `graphWebhookUrl` config field already exists. No changes needed unless it is empty -- add a startup warning log in server.ts if `config.graphWebhookUrl` is empty (webhook subscriptions will fail without it).
  </action>
  <verify>
    1. `cd /home/admin/claude/MSEDB && docker compose exec backend npx tsc --noEmit` passes
    2. subscriptionService.ts exports createSubscription, renewSubscription, deleteSubscription, syncSubscriptionsOnStartup, handleLifecycleEvent
    3. webhookRenewal.ts exports processWebhookRenewal
    4. queues.ts processorMap maps 'webhook-renewal' to processWebhookRenewal (not placeholder)
    5. server.ts calls syncSubscriptionsOnStartup() during startup
  </verify>
  <done>
    Subscription service manages full lifecycle (create, renew, delete, lifecycle event handling). Webhook-renewal processor wired as real BullMQ processor. Server startup syncs all subscriptions. Missing GRAPH_WEBHOOK_URL logged as warning.
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 3: Verify Cloudflare Tunnel is operational</name>
  <what-built>
    Graph API client, webhook handler with clientState validation and BullMQ enqueue, subscription service with full lifecycle management, and webhook-renewal processor are all implemented. However, live webhook functionality requires Cloudflare Tunnel to be operational (deferred from Phase 1 by user decision).
  </what-built>
  <action>
    Set up Cloudflare Tunnel to forward HTTPS traffic to backend port 8010. Required steps:

    1. On the DGX host (NOT inside Docker), install cloudflared:
       `curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o /usr/local/bin/cloudflared && chmod +x /usr/local/bin/cloudflared`

    2. Authenticate: `cloudflared tunnel login`

    3. Create tunnel: `cloudflared tunnel create msedb-webhooks`

    4. Configure `~/.cloudflared/config.yml`:
       ```yaml
       tunnel: <tunnel-id>
       credentials-file: /root/.cloudflared/<tunnel-id>.json
       ingress:
         - hostname: msedb-webhooks.yourdomain.com
           service: http://localhost:8010
         - service: http_status:404
       ```

    5. Route DNS: `cloudflared tunnel route dns msedb-webhooks msedb-webhooks.yourdomain.com`

    6. Install as systemd service: `cloudflared service install`

    7. Start: `systemctl start cloudflared`

    8. Set environment variable in backend .env:
       `GRAPH_WEBHOOK_URL=https://msedb-webhooks.yourdomain.com`

    9. If on Cloudflare Free plan: disable Bot Fight Mode entirely (Cloudflare dashboard -> Security -> Bots). If on Pro plan: add a WAF Skip rule for `/webhooks/graph` path.

    10. Restart backend container: `docker compose restart backend`
  </action>
  <how-to-verify>
    After Cloudflare Tunnel is set up and GRAPH_WEBHOOK_URL is configured:

    1. Test tunnel connectivity:
       `curl -X POST "https://<your-tunnel-hostname>/webhooks/graph?validationToken=test123"`
       Expected: returns `test123` as text/plain with status 200

    2. Check backend logs for subscription sync:
       `docker compose logs backend --tail=50`
       Expected: "Webhook renewal job started" or "syncSubscriptionsOnStartup" log entries
       (If no mailboxes are connected yet, it will log "0 mailboxes found" which is fine)
  </how-to-verify>
  <resume-signal>Type "tunnel ready" once Cloudflare Tunnel is operational and the validation test passes, or "skip tunnel" to continue without it (webhook subscriptions will fail until configured)</resume-signal>
</task>

</tasks>

<verification>
- `docker compose exec backend npx tsc --noEmit` compiles cleanly
- 6 BullMQ queues exist (webhook-events added)
- webhook-renewal processor is real (not placeholder)
- Webhook handler returns 202 before any async work
- graphFetch sends Bearer token on all requests
- subscriptionService uses `users/{email}/messages` resource path (not `me/messages`)
- Cloudflare Tunnel forwards to backend (if configured)
</verification>

<success_criteria>
- Graph API client provides authenticated fetch wrapper for all Phase 3 services
- Webhook handler validates clientState and routes change/lifecycle notifications to separate BullMQ queues
- Subscription service creates, renews, and recreates webhook subscriptions with lifecycleNotificationUrl
- Webhook-renewal processor handles scheduled renewal (every 2h) and lifecycle events (subscriptionRemoved, missed, reauthorizationRequired)
- Server startup syncs all mailbox subscriptions
- Cloudflare Tunnel operational (or user explicitly skips)
</success_criteria>

<output>
After completion, create `.planning/phases/03-email-observation-pipeline/03-01-SUMMARY.md`
</output>
