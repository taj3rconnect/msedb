---
phase: 04-frontend-shell-observation-ui
plan: 03
type: execute
wave: 3
depends_on:
  - "04-02"
files_modified:
  - backend/src/routes/events.ts
  - backend/src/server.ts
  - frontend/src/api/events.ts
  - frontend/src/hooks/useEvents.ts
  - frontend/src/components/events/EventsTable.tsx
  - frontend/src/components/events/EventFilters.tsx
  - frontend/src/components/events/EventTimeline.tsx
  - frontend/src/components/events/SenderBreakdown.tsx
  - frontend/src/pages/EmailActivityPage.tsx
autonomous: true
requirements:
  - PAGE-01
  - DASH-02

must_haves:
  truths:
    - "User can see email events in a paginated, sortable table"
    - "User can filter events by mailbox, event type, and sender domain"
    - "Event timeline chart shows event distribution over time (24h or 30d)"
    - "Sender breakdown chart shows top senders by event count"
    - "New events appear in the activity page via Socket.IO without page refresh"
  artifacts:
    - path: "backend/src/routes/events.ts"
      provides: "GET /api/events, GET /api/events/sender-breakdown, GET /api/events/timeline"
      exports: ["eventsRouter"]
    - path: "frontend/src/pages/EmailActivityPage.tsx"
      provides: "Email activity page composing table, filters, timeline, sender breakdown"
      contains: "EventsTable"
    - path: "frontend/src/components/events/EventsTable.tsx"
      provides: "TanStack Table with sortable columns and pagination"
      contains: "useReactTable"
    - path: "frontend/src/components/events/EventTimeline.tsx"
      provides: "Recharts area/bar chart for event counts over time"
      contains: "ResponsiveContainer"
    - path: "frontend/src/components/events/SenderBreakdown.tsx"
      provides: "Recharts bar chart of top sender domains"
      contains: "ResponsiveContainer"
  key_links:
    - from: "frontend/src/pages/EmailActivityPage.tsx"
      to: "/api/events"
      via: "useEvents TanStack Query hook"
      pattern: "useEvents"
    - from: "frontend/src/components/events/EventTimeline.tsx"
      to: "/api/events/timeline"
      via: "useEventTimeline hook"
      pattern: "events/timeline"
    - from: "frontend/src/components/events/SenderBreakdown.tsx"
      to: "/api/events/sender-breakdown"
      via: "useSenderBreakdown hook"
      pattern: "events/sender-breakdown"
    - from: "frontend/src/hooks/useEvents.ts"
      to: "frontend/src/hooks/useSocket.ts"
      via: "Socket.IO invalidates ['events'] query key"
      pattern: "invalidateQueries.*events"
---

<objective>
Build the email activity page with a filterable, paginated data table, event timeline chart, and sender breakdown visualization, backed by new API endpoints.

Purpose: This page lets users verify the observation pipeline is working by browsing all collected email events with rich filtering and visual analysis. Real-time Socket.IO updates (wired in Plan 02) automatically refresh this data.
Output: Working email activity page with data table, charts, filters, and backend API endpoints for paginated/filterable events with aggregation queries.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-frontend-shell-observation-ui/04-RESEARCH.md
@.planning/phases/04-frontend-shell-observation-ui/04-02-SUMMARY.md
@backend/src/server.ts
@backend/src/auth/middleware.ts
@backend/src/models/EmailEvent.ts
@frontend/src/App.tsx
@frontend/src/api/client.ts
@frontend/src/hooks/useSocket.ts
@frontend/src/stores/uiStore.ts
@frontend/src/lib/constants.ts
@frontend/src/lib/formatters.ts
@frontend/src/components/shared/EmptyState.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Events API endpoints (paginated, filterable, with aggregations)</name>
  <files>
    backend/src/routes/events.ts
    backend/src/server.ts
  </files>
  <action>
1. Create `backend/src/routes/events.ts` with requireAuth middleware. Three endpoints:

   **GET /api/events** (paginated, filterable):
   - Query params: mailboxId, eventType, senderDomain, page (1-based, default 1), limit (default 50, max 200), sortBy (default 'timestamp'), sortOrder (default 'desc')
   - Build match filter: always filter by userId from JWT. Add optional filters for mailboxId, eventType, sender.domain (use 'sender.domain' as the MongoDB field path)
   - Use Promise.all for parallel query + count
   - Select fields: eventType, sender, subject, timestamp, mailboxId, fromFolder, toFolder, importance, hasAttachments, categories, isRead
   - Return: { events: [...], pagination: { page, limit, total, totalPages } }

   **GET /api/events/sender-breakdown**:
   - Aggregate: group by sender.domain, count, get latest event timestamp per domain
   - Sort by count descending, limit to top 20
   - Optional ?mailboxId filter
   - Return: { breakdown: [{ _id: domain, count, latestEvent }] }

   **GET /api/events/timeline**:
   - Query param: range ('24h' or '30d', default '24h')
   - 24h: group by hour (format '%Y-%m-%dT%H:00'), since 24 hours ago
   - 30d: group by day (format '%Y-%m-%d'), since 30 days ago
   - Optional ?mailboxId filter
   - Sort by time bucket ascending
   - Return: { timeline: [{ _id: timeBucket, count }], range }

2. Mount eventsRouter in `backend/src/server.ts`:
   - Import eventsRouter from './routes/events.js'
   - Add `app.use('/api/events', eventsRouter);` BEFORE the global error handler

3. Verify: `cd backend && npx tsc --noEmit`
  </action>
  <verify>
    - `cd backend && npx tsc --noEmit` compiles without errors
    - `grep -r "eventsRouter" backend/src/server.ts` confirms route mounting
    - backend/src/routes/events.ts exists with GET /, GET /sender-breakdown, GET /timeline
  </verify>
  <done>
    - GET /api/events returns paginated email events with filtering by mailbox, event type, sender domain
    - GET /api/events/sender-breakdown returns top 20 sender domains by event count
    - GET /api/events/timeline returns hourly (24h) or daily (30d) event counts
    - All endpoints require authentication and filter by userId
    - Backend compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Email activity page with data table, filters, timeline, and sender breakdown</name>
  <files>
    frontend/src/api/events.ts
    frontend/src/hooks/useEvents.ts
    frontend/src/components/events/EventsTable.tsx
    frontend/src/components/events/EventFilters.tsx
    frontend/src/components/events/EventTimeline.tsx
    frontend/src/components/events/SenderBreakdown.tsx
    frontend/src/pages/EmailActivityPage.tsx
    frontend/src/App.tsx
  </files>
  <action>
1. Create `frontend/src/api/events.ts`:
   - `fetchEvents(params: { mailboxId?, eventType?, senderDomain?, page?, limit?, sortBy?, sortOrder? })` -- GET /events with query string built from params (skip undefined values)
   - `fetchSenderBreakdown(mailboxId?: string)` -- GET /events/sender-breakdown?mailboxId=
   - `fetchEventTimeline(mailboxId?: string, range?: '24h' | '30d')` -- GET /events/timeline?mailboxId=&range=

2. Create `frontend/src/hooks/useEvents.ts`:
   - `useEvents(params)` -- useQuery with key ['events', 'list', params], calls fetchEvents. Params include page, limit, sortBy, sortOrder, and filters.
   - `useSenderBreakdown(mailboxId?)` -- useQuery with key ['events', 'sender-breakdown', mailboxId], calls fetchSenderBreakdown
   - `useEventTimeline(mailboxId?, range?)` -- useQuery with key ['events', 'timeline', mailboxId, range], calls fetchEventTimeline
   - Note: Socket.IO (from Plan 02 useSocket) already invalidates ['events'] queries, so these auto-refresh on new events.

3. Create `frontend/src/components/events/EventFilters.tsx`:
   - Row of filter controls using shadcn Select components:
     - Event type: "All Types" + dropdown of all event types from constants
     - Sender domain: text input (shadcn Input) for domain search/filter
   - Note: Mailbox filter is handled by the global MailboxSelector in Topbar
   - Fires onChange callback with updated filter params
   - Also include a range toggle for the timeline chart (24h / 30d) using shadcn Button group

4. Create `frontend/src/components/events/EventsTable.tsx`:
   - Use @tanstack/react-table with shadcn Table components
   - Columns: Event Type (badge), Sender (email + domain), Subject (truncated), Folder (from -> to for moves), Timestamp (relative), Attachments (paperclip icon if true)
   - Column sorting via TanStack Table (server-side sorting -- pass sortBy/sortOrder to API)
   - Client-rendered pagination controls at bottom: Previous/Next buttons with page X of Y
   - Use Skeleton rows while loading
   - Empty state when no events match filters
   - Pass page/limit/sort state up to parent for API query params

5. Create `frontend/src/components/events/EventTimeline.tsx`:
   - Use Recharts AreaChart (or BarChart) wrapped in shadcn Chart component (if available) or raw ResponsiveContainer
   - X-axis: time buckets (hours or dates)
   - Y-axis: event count
   - Tooltip showing exact count and time
   - Use the OKLCH theme colors for chart elements
   - Accept data prop: { timeline: [{ _id: string, count: number }], range: string }
   - Loading skeleton while data loads
   - Format X-axis labels: for 24h show "HH:00", for 30d show "MMM dd"

6. Create `frontend/src/components/events/SenderBreakdown.tsx`:
   - Use Recharts horizontal BarChart
   - Show top 10 sender domains (from the 20 returned by API) with count bars
   - Tooltip showing domain and exact count
   - Accept data prop: { breakdown: [{ _id: string, count: number }] }
   - Loading skeleton while data loads
   - Truncate long domain names in Y-axis labels

7. Create `frontend/src/pages/EmailActivityPage.tsx`:
   - Manages filter state locally: { eventType, senderDomain, page, limit, sortBy, sortOrder, timelineRange }
   - Reads selectedMailboxId from uiStore for mailbox filtering
   - Layout: two sections
     - Top: Charts row -- EventTimeline (wider, ~60%) and SenderBreakdown (narrower, ~40%) side by side on desktop, stacked on mobile
     - Bottom: EventFilters above EventsTable
   - Uses all three hooks: useEvents, useSenderBreakdown, useEventTimeline
   - Page title: "Email Activity"
   - Handles loading/error states with Skeleton and EmptyState components

8. Update `frontend/src/App.tsx`:
   - Replace the placeholder /activity route element with <EmailActivityPage />
   - Import EmailActivityPage

9. Verify: `cd frontend && npx tsc -b && npx vite build`
  </action>
  <verify>
    - `cd frontend && npx tsc -b` compiles without errors
    - `cd frontend && npx vite build` produces dist/ output
    - All event component files exist: EventsTable.tsx, EventFilters.tsx, EventTimeline.tsx, SenderBreakdown.tsx
    - frontend/src/pages/EmailActivityPage.tsx exists
    - `grep -r "EmailActivityPage" frontend/src/App.tsx` confirms route wiring
  </verify>
  <done>
    - Email activity page renders with data table, timeline chart, and sender breakdown chart
    - Events table is paginated with server-side sorting and client-side page navigation
    - Filters work: event type dropdown and sender domain input filter the table
    - Timeline chart shows event counts by hour (24h) or day (30d) with toggle
    - Sender breakdown shows top domains by event count as horizontal bar chart
    - Mailbox selector in topbar filters all data to selected mailbox
    - Socket.IO invalidation causes automatic refresh when new events arrive
    - TypeScript compiles and Vite builds successfully
  </done>
</task>

</tasks>

<verification>
- `cd backend && npx tsc --noEmit` passes
- `cd frontend && npx tsc -b && npx vite build` passes
- Backend: Three event endpoints return correct data shapes
- Frontend: Email activity page renders table + 2 charts
- Frontend: Pagination controls navigate pages
- Frontend: Filters update the table data
- Frontend: Charts render with recharts (no empty container issue)
- Integration: MailboxSelector filters events page data
- Integration: Socket.IO events trigger query invalidation on events page
</verification>

<success_criteria>
- Email events displayed in sortable, paginated table with event type, sender, subject, folder, timestamp columns
- Event type and sender domain filters narrow the results
- Timeline chart visualizes email volume over time (24h/30d toggle)
- Sender breakdown chart shows top sender domains ranked by count
- Per-mailbox filtering works via global mailbox selector
- Real-time updates: new events trigger automatic data refresh
- Both backend and frontend compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-shell-observation-ui/04-03-SUMMARY.md`
</output>
