---
phase: 04-frontend-shell-observation-ui
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - backend/src/config/socket.ts
  - backend/src/server.ts
  - backend/src/routes/dashboard.ts
  - backend/src/routes/user.ts
  - backend/src/services/eventCollector.ts
  - backend/package.json
  - frontend/nginx.conf
  - frontend/src/hooks/useSocket.ts
  - frontend/src/hooks/useDashboard.ts
  - frontend/src/hooks/useKillSwitch.ts
  - frontend/src/hooks/useMailboxes.ts
  - frontend/src/api/dashboard.ts
  - frontend/src/api/mailboxes.ts
  - frontend/src/api/user.ts
  - frontend/src/components/layout/AppShell.tsx
  - frontend/src/components/layout/AppSidebar.tsx
  - frontend/src/components/layout/Topbar.tsx
  - frontend/src/components/layout/KillSwitch.tsx
  - frontend/src/components/dashboard/StatsCards.tsx
  - frontend/src/components/dashboard/ActivityFeed.tsx
  - frontend/src/components/dashboard/PendingSuggestionsSection.tsx
  - frontend/src/components/shared/MailboxSelector.tsx
  - frontend/src/components/shared/EmptyState.tsx
  - frontend/src/pages/DashboardPage.tsx
  - frontend/src/pages/ComingSoonPage.tsx
  - frontend/src/lib/formatters.ts
  - frontend/src/lib/constants.ts
  - frontend/src/App.tsx
autonomous: true
requirements:
  - DASH-01
  - DASH-02

must_haves:
  truths:
    - "User sees dashboard with 4 stats cards (emails processed, rules fired, patterns pending, staging count)"
    - "Dashboard shows activity feed with recent email events"
    - "Dashboard shows a pending suggestions section (empty state until Phase 5 provides pattern data)"
    - "User can switch between aggregate and per-mailbox views"
    - "New email events appear on dashboard within seconds via Socket.IO without page refresh"
    - "Kill switch toggle is visible in top navigation on every page"
    - "Sidebar navigation has links to all pages (dashboard, activity, patterns, rules, staging, audit, settings)"
  artifacts:
    - path: "backend/src/config/socket.ts"
      provides: "Socket.IO server with JWT cookie auth and user-scoped rooms"
      contains: "SocketServer"
    - path: "backend/src/routes/dashboard.ts"
      provides: "GET /api/dashboard/stats and GET /api/dashboard/activity endpoints"
      exports: ["dashboardRouter"]
    - path: "backend/src/routes/user.ts"
      provides: "PATCH /api/user/preferences endpoint for kill switch toggle"
      exports: ["userRouter"]
    - path: "frontend/src/components/layout/AppShell.tsx"
      provides: "Main layout with sidebar and topbar wrapping page content"
      contains: "SidebarProvider"
    - path: "frontend/src/components/layout/KillSwitch.tsx"
      provides: "Automation pause toggle in top navigation"
      contains: "Switch"
    - path: "frontend/src/hooks/useSocket.ts"
      provides: "Socket.IO connection with TanStack Query cache invalidation"
      contains: "io("
    - path: "frontend/src/pages/DashboardPage.tsx"
      provides: "Dashboard page composing StatsCards, ActivityFeed, and PendingSuggestionsSection"
      contains: "PendingSuggestionsSection"
    - path: "frontend/src/components/dashboard/PendingSuggestionsSection.tsx"
      provides: "Empty state stub for pending pattern suggestions (populated in Phase 5)"
      contains: "No patterns detected yet"
    - path: "frontend/nginx.conf"
      provides: "WebSocket proxy for Socket.IO"
      contains: "socket.io"
  key_links:
    - from: "backend/src/services/eventCollector.ts"
      to: "backend/src/config/socket.ts"
      via: "getIO().to(user:userId).emit after EmailEvent save"
      pattern: "getIO.*emit.*email:event"
    - from: "backend/src/config/socket.ts"
      to: "backend/src/server.ts"
      via: "createSocketServer(app) replaces app.listen()"
      pattern: "httpServer.listen"
    - from: "frontend/src/hooks/useSocket.ts"
      to: "frontend/src/hooks/useDashboard.ts"
      via: "invalidateQueries on email:event"
      pattern: "invalidateQueries.*dashboard"
    - from: "frontend/src/pages/DashboardPage.tsx"
      to: "/api/dashboard/stats"
      via: "useDashboardStats TanStack Query hook"
      pattern: "dashboard/stats"
    - from: "frontend/src/components/layout/KillSwitch.tsx"
      to: "/api/user/preferences"
      via: "PATCH request to toggle automationPaused"
      pattern: "api/user/preferences"
---

<objective>
Build the app shell layout (sidebar, topbar with kill switch) and dashboard page with stats cards, activity feed, and pending suggestions section, backed by new API endpoints and Socket.IO real-time updates.

Purpose: This plan delivers the core user experience -- the layout that persists across all pages and the dashboard that proves the observation pipeline is working. Socket.IO integration enables real-time visibility into email events.
Output: Working dashboard with live-updating stats, activity feed, and pending suggestions empty state; sidebar navigation; kill switch toggle; Socket.IO server+client; dashboard and user API endpoints.

NOTE on DASH-02 (real-time updates): This plan implements Socket.IO real-time updates for email events only. Real-time updates for patterns, rules, and staging events will be wired in Phases 5 and 6 as those subsystems are built.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-frontend-shell-observation-ui/04-RESEARCH.md
@.planning/phases/04-frontend-shell-observation-ui/04-01-SUMMARY.md
@backend/src/server.ts
@backend/src/config/index.ts
@backend/src/services/eventCollector.ts
@backend/src/auth/middleware.ts
@backend/src/models/EmailEvent.ts
@backend/src/models/User.ts
@backend/src/models/Mailbox.ts
@frontend/nginx.conf
@frontend/src/App.tsx
@frontend/src/stores/authStore.ts
@frontend/src/stores/uiStore.ts
@frontend/src/api/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Socket.IO server, dashboard API endpoints, user preferences endpoint, and event emission wiring</name>
  <files>
    backend/src/config/socket.ts
    backend/src/server.ts
    backend/src/routes/dashboard.ts
    backend/src/routes/user.ts
    backend/src/services/eventCollector.ts
    backend/package.json
    frontend/nginx.conf
  </files>
  <action>
1. Install Socket.IO on the backend:
   ```
   cd backend && npm install socket.io
   ```

2. Create `backend/src/config/socket.ts` -- Socket.IO server with JWT cookie auth:
   - Export `createSocketServer(app: Express)` that returns `{ httpServer, io }`
   - Create HTTP server with `createServer(app)`
   - Create Socket.IO server attached to httpServer with CORS origin from config.appUrl, credentials: true
   - io.use() middleware: parse cookies from socket.handshake.headers.cookie, extract msedb_session cookie, verify JWT with jwt.verify(token, config.jwtSecret), store decoded user in socket.data.user
   - io.on('connection'): join `user:${userId}` room, log connection, handle disconnect
   - Export `getIO()` function that returns the io instance (stored in module-level variable, throws if not initialized)
   - CRITICAL: Use the simple cookie parsing from research (split by ';', split by '='). Do NOT import cookie-parser for this -- it's handshake headers, not Express middleware.

3. Modify `backend/src/server.ts`:
   - Import createSocketServer from ./config/socket.js
   - CRITICAL CHANGE: Replace `app.listen(config.port, ...)` with:
     ```typescript
     const { httpServer, io } = createSocketServer(app);
     httpServer.listen(config.port, () => { ... });
     ```
   - Store io on app for potential health check access: `app.set('io', io)`
   - Keep all existing middleware, routes, and startup sequence EXACTLY as-is. Only change the listen() call.
   - Mount dashboardRouter at '/api/dashboard'
   - Mount userRouter at '/api/user' -- this is a DEDICATED router, NOT nested inside dashboard

4. Create `backend/src/routes/dashboard.ts` with requireAuth middleware:
   - GET /stats: Returns { emailsProcessed, rulesFired: 0, patternsPending: 0, stagingCount: 0, perMailbox: [...] }
     - emailsProcessed = EmailEvent.countDocuments({ userId })
     - perMailbox = EmailEvent.aggregate group by mailboxId with count
     - Join mailbox info (email, displayName) from Mailbox model
     - Optional ?mailboxId query param for per-mailbox filtering
   - GET /activity: Returns { events: [...] }
     - Find EmailEvent for userId, sorted by timestamp desc, limited to 50 (configurable via ?limit, max 200)
     - Select: eventType, sender, subject, timestamp, mailboxId, fromFolder, toFolder
     - Optional ?mailboxId query param

5. Create `backend/src/routes/user.ts` with requireAuth middleware:
   - PATCH /preferences: Accepts { automationPaused: boolean }, updates User.preferences.automationPaused, returns updated preferences
   - This is mounted at /api/user, so the full URL is /api/user/preferences
   - This is the kill switch endpoint -- it MUST be at /api/user/preferences (not /api/dashboard/user/preferences)

6. Modify `backend/src/services/eventCollector.ts`:
   - Import getIO from '../config/socket.js'
   - After a successful EmailEvent save (after the document is persisted to MongoDB), emit a Socket.IO event:
     ```typescript
     try {
       const io = getIO();
       io.to(`user:${userId}`).emit('email:event', {
         id: savedEvent._id,
         eventType: savedEvent.eventType,
         sender: savedEvent.sender,
         subject: savedEvent.subject,
         timestamp: savedEvent.timestamp,
         mailboxId: savedEvent.mailboxId,
       });
     } catch {
       // Socket.IO not initialized (e.g., during tests) -- ignore silently
     }
     ```
   - Wrap in try/catch so Socket.IO failures never break event collection.

7. Update `frontend/nginx.conf` -- add Socket.IO proxy location block BEFORE the SPA catch-all:
   ```nginx
   location /socket.io/ {
       proxy_pass http://msedb-backend:8010/socket.io/;
       proxy_http_version 1.1;
       proxy_set_header Upgrade $http_upgrade;
       proxy_set_header Connection "upgrade";
       proxy_set_header Host $host;
       proxy_set_header X-Real-IP $remote_addr;
       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
       proxy_set_header X-Forwarded-Proto $scheme;
       proxy_read_timeout 86400s;
       proxy_send_timeout 86400s;
   }
   ```

8. Verify backend compiles: `cd backend && npx tsc --noEmit`
  </action>
  <verify>
    - `cd backend && npx tsc --noEmit` compiles without errors
    - `grep -r "httpServer.listen" backend/src/server.ts` confirms Socket.IO integration
    - `grep -r "getIO" backend/src/services/eventCollector.ts` confirms event emission
    - `grep -r "socket.io" frontend/nginx.conf` confirms WebSocket proxy
    - `grep -r "/api/user" backend/src/server.ts` confirms dedicated user router mount
    - `grep -r "preferences" backend/src/routes/user.ts` confirms kill switch endpoint
    - backend/src/config/socket.ts exists
    - backend/src/routes/dashboard.ts exists
    - backend/src/routes/user.ts exists
  </verify>
  <done>
    - Socket.IO server attached to HTTP server with JWT cookie auth and user-scoped rooms
    - server.ts uses httpServer.listen instead of app.listen
    - Dashboard stats and activity endpoints return real EmailEvent data
    - Kill switch endpoint at /api/user/preferences (dedicated userRouter) updates User.preferences
    - Event collector emits Socket.IO events after EmailEvent saves
    - Nginx proxies /socket.io/ WebSocket connections to backend
    - Backend compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Layout shell, hooks, API modules, and utility files</name>
  <files>
    frontend/src/lib/constants.ts
    frontend/src/lib/formatters.ts
    frontend/src/api/dashboard.ts
    frontend/src/api/mailboxes.ts
    frontend/src/api/user.ts
    frontend/src/hooks/useSocket.ts
    frontend/src/hooks/useDashboard.ts
    frontend/src/hooks/useKillSwitch.ts
    frontend/src/hooks/useMailboxes.ts
    frontend/src/components/shared/EmptyState.tsx
    frontend/src/components/shared/MailboxSelector.tsx
  </files>
  <action>
1. Create `frontend/src/lib/constants.ts`:
   - EVENT_TYPES: Record of event type labels and colors (arrived=blue, deleted=red, moved=yellow, read=green, flagged=purple, categorized=indigo)
   - ROUTE_PATHS: { dashboard: '/', activity: '/activity', patterns: '/patterns', rules: '/rules', staging: '/staging', audit: '/audit', settings: '/settings', login: '/login' }
   - NAV_ITEMS: Array of { label, path, icon (lucide icon name) } for sidebar navigation

2. Create `frontend/src/lib/formatters.ts`:
   - `formatRelativeTime(date: string | Date): string` -- uses date-fns formatDistanceToNow with addSuffix: true
   - `formatNumber(n: number): string` -- n.toLocaleString()
   - `formatEmail(email?: string): string` -- truncate long emails, handle undefined
   - `formatEventType(type: string): string` -- capitalize and humanize event type names

3. Create `frontend/src/api/dashboard.ts`:
   - `fetchDashboardStats(mailboxId?: string)` -- GET /dashboard/stats?mailboxId=
   - `fetchDashboardActivity(mailboxId?: string, limit?: number)` -- GET /dashboard/activity?mailboxId=&limit=

4. Create `frontend/src/api/user.ts`:
   - `updatePreferences(prefs: { automationPaused: boolean })` -- PATCH /user/preferences
   - IMPORTANT: The URL is /user/preferences (apiFetch prepends /api, making it /api/user/preferences). Do NOT use /dashboard/user/preferences.

5. Create `frontend/src/api/mailboxes.ts`:
   - `fetchMailboxes()` -- GET /mailboxes (already exists from Phase 2's mailbox router which has GET / for listing)

6. Create `frontend/src/hooks/useSocket.ts`:
   - Connect to Socket.IO on mount with `io({ withCredentials: true })` -- no URL needed, defaults to same origin
   - Listen for 'email:event' -- invalidate ['dashboard'] and ['events'] query keys
   - Listen for 'connect_error' -- log to console
   - Return socket ref
   - Cleanup: disconnect on unmount
   - IMPORTANT: Create socket connection exactly ONCE. Use useRef to prevent reconnection on re-renders.

7. Create `frontend/src/hooks/useDashboard.ts`:
   - `useDashboardStats(mailboxId?: string | null)` -- useQuery with key ['dashboard', 'stats', mailboxId], calls fetchDashboardStats
   - `useDashboardActivity(mailboxId?: string | null)` -- useQuery with key ['dashboard', 'activity', mailboxId], calls fetchDashboardActivity

8. Create `frontend/src/hooks/useKillSwitch.ts`:
   - useMutation calling updatePreferences({ automationPaused }) from api/user.ts
   - On success: update authStore.user.preferences.automationPaused optimistically
   - Invalidate dashboard queries on success

9. Create `frontend/src/hooks/useMailboxes.ts`:
   - useQuery with key ['mailboxes'], calls fetchMailboxes
   - Return { mailboxes, isLoading }

10. Create `frontend/src/components/shared/EmptyState.tsx`:
    - Accepts title, description, icon (LucideIcon) props
    - Renders centered icon + text in muted colors

11. Create `frontend/src/components/shared/MailboxSelector.tsx`:
    - Select dropdown showing "All Mailboxes" + list of connected mailboxes from authStore.mailboxes
    - On change: update uiStore.selectedMailboxId
    - Use shadcn Select component

12. Verify: `cd frontend && npx tsc -b`
  </action>
  <verify>
    - `cd frontend && npx tsc -b` compiles without errors
    - All utility files exist: constants.ts, formatters.ts
    - All API files exist: dashboard.ts, mailboxes.ts, user.ts
    - All hook files exist: useSocket.ts, useDashboard.ts, useKillSwitch.ts, useMailboxes.ts
    - All shared component files exist: EmptyState.tsx, MailboxSelector.tsx
    - `grep -r "user/preferences" frontend/src/api/user.ts` confirms correct kill switch URL
  </verify>
  <done>
    - Utility modules (constants, formatters) provide shared values for all dashboard components
    - API modules call correct backend endpoints (dashboard at /api/dashboard/*, user at /api/user/*)
    - Socket.IO hook connects on mount and invalidates TanStack Query caches on email:event
    - Dashboard hooks wrap TanStack Query for stats and activity data
    - Kill switch hook calls /api/user/preferences (definitively, not /api/dashboard/user/preferences)
    - Mailbox selector and empty state components ready for composition
    - TypeScript compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 3: Dashboard components, layout shell, pages, and App.tsx update</name>
  <files>
    frontend/src/components/layout/AppShell.tsx
    frontend/src/components/layout/AppSidebar.tsx
    frontend/src/components/layout/Topbar.tsx
    frontend/src/components/layout/KillSwitch.tsx
    frontend/src/components/dashboard/StatsCards.tsx
    frontend/src/components/dashboard/ActivityFeed.tsx
    frontend/src/components/dashboard/PendingSuggestionsSection.tsx
    frontend/src/pages/DashboardPage.tsx
    frontend/src/pages/ComingSoonPage.tsx
    frontend/src/App.tsx
  </files>
  <action>
1. Create `frontend/src/components/layout/KillSwitch.tsx`:
   - shadcn Switch component showing automation state
   - Label: "Automation" with small status indicator (green=active, red=paused)
   - Toggle calls useKillSwitch mutation
   - Reads automationPaused from authStore.user.preferences
   - IMPORTANT: This is prominent (not hidden) per SAFE-02 requirements -- visible on every page

2. Create `frontend/src/components/layout/Topbar.tsx`:
   - Horizontal bar at top of content area
   - Left: SidebarTrigger (hamburger) for mobile, breadcrumb or page title
   - Center/Right: MailboxSelector, KillSwitch, user avatar with dropdown menu (shows email, logout option)
   - Use shadcn DropdownMenu for user menu, Avatar component

3. Create `frontend/src/components/layout/AppSidebar.tsx`:
   - Use shadcn Sidebar component
   - Logo/title at top: "MSEDB" with mail icon
   - Navigation items from NAV_ITEMS constant with lucide icons:
     - Dashboard (LayoutDashboard)
     - Email Activity (Mail)
     - Patterns (Brain)
     - Rules (Shield)
     - Staging (Clock)
     - Audit Log (FileText)
     - Settings (Settings)
   - Use NavLink from react-router for active state highlighting
   - Collapsible on mobile

4. Create `frontend/src/components/layout/AppShell.tsx`:
   - Wraps content in shadcn SidebarProvider + SidebarInset
   - Renders AppSidebar + Topbar + main content area (children/Outlet)
   - Full height layout with sidebar on left, content on right

5. Create `frontend/src/components/dashboard/StatsCards.tsx`:
   - 4 cards in a responsive grid (1 col mobile, 2 cols md, 4 cols lg)
   - Cards: Emails Processed (Mail icon, blue), Rules Fired (Shield, green), Patterns Pending (Brain, yellow), In Staging (Clock, orange)
   - Each card shows formatted number value
   - Use shadcn Card component
   - Accept props: { emailsProcessed, rulesFired, patternsPending, stagingCount }

6. Create `frontend/src/components/dashboard/ActivityFeed.tsx`:
   - Scrollable list of recent email events using shadcn ScrollArea
   - Each item shows: event type badge (colored), sender email, subject (truncated), relative timestamp
   - Empty state when no events
   - Use shadcn Badge for event types with colors from constants
   - Accept props: { events: Array<{ eventType, sender, subject, timestamp, mailboxId }> }

7. Create `frontend/src/components/dashboard/PendingSuggestionsSection.tsx`:
   - This is a STUB component that will be populated by Phase 5 (Pattern Intelligence)
   - For now, render an empty state using the EmptyState component or a shadcn Card:
     - Icon: Brain (from lucide-react)
     - Title: "No Patterns Detected Yet"
     - Description: "The system needs at least 14 days of email observation to detect patterns. Check back soon."
   - Accepts an optional `suggestions` prop (empty array for now, typed as `PatternSuggestion[]` or `unknown[]`)
   - When suggestions are present (future), render suggestion cards. For now, only the empty state path is implemented.
   - This fulfills the "pending suggestions" part of DASH-01.

8. Create `frontend/src/pages/DashboardPage.tsx`:
   - Uses useDashboardStats and useDashboardActivity hooks with uiStore.selectedMailboxId
   - Layout sections:
     - Top: StatsCards with stats data
     - Middle: PendingSuggestionsSection (empty state for now)
     - Bottom: ActivityFeed with activity data
   - Loading skeletons while data loads (shadcn Skeleton)
   - Error states with EmptyState component

9. Create `frontend/src/pages/ComingSoonPage.tsx`:
   - Accepts title prop
   - Shows centered "Coming Soon" message with the page title
   - Used for placeholder routes (patterns, rules, staging, audit, settings)

10. Update `frontend/src/App.tsx`:
    - Wrap ProtectedLayout in AppShell (import from layout components)
    - Initialize Socket.IO via useSocket() hook inside ProtectedLayout (only connect when authenticated)
    - Replace placeholder route elements with DashboardPage, ComingSoonPage, etc.
    - Keep existing router structure, just update the components

11. Verify: `cd frontend && npx tsc -b && npx vite build`
  </action>
  <verify>
    - `cd frontend && npx tsc -b` compiles without errors
    - `cd frontend && npx vite build` produces dist/ output
    - All layout files exist: AppShell.tsx, AppSidebar.tsx, Topbar.tsx, KillSwitch.tsx
    - All dashboard files exist: StatsCards.tsx, ActivityFeed.tsx, PendingSuggestionsSection.tsx, DashboardPage.tsx
    - `grep -r "PendingSuggestionsSection" frontend/src/pages/DashboardPage.tsx` confirms pending suggestions integrated
    - `grep -r "No Patterns Detected" frontend/src/components/dashboard/PendingSuggestionsSection.tsx` confirms empty state text
    - `grep -r "useSocket" frontend/src/App.tsx` confirms Socket.IO initialization
    - `grep -r "AppShell" frontend/src/App.tsx` confirms layout integration
  </verify>
  <done>
    - App shell renders sidebar navigation with links to all 7 pages
    - Topbar shows mailbox selector, kill switch toggle, and user menu on every page
    - Dashboard page displays 4 stats cards with data from /api/dashboard/stats
    - Dashboard page includes pending suggestions section with empty state ("No Patterns Detected Yet")
    - Activity feed shows recent email events from /api/dashboard/activity
    - Mailbox selector switches between aggregate and per-mailbox views
    - Socket.IO connects on authentication and invalidates dashboard queries on email:event
    - Kill switch toggles User.preferences.automationPaused via /api/user/preferences
    - Placeholder pages render "Coming Soon" for unbuilt features
    - TypeScript compiles and Vite builds successfully
  </done>
</task>

</tasks>

<verification>
- `cd backend && npx tsc --noEmit` passes
- `cd frontend && npx tsc -b && npx vite build` passes
- Backend: Socket.IO server initializes with JWT cookie auth
- Backend: Dashboard stats/activity endpoints query EmailEvent model
- Backend: User preferences endpoint at /api/user/preferences (dedicated router, not nested in dashboard)
- Backend: Event collector emits Socket.IO events after saves
- Frontend: Dashboard page renders stats cards, pending suggestions empty state, and activity feed
- Frontend: Sidebar has navigation to all pages
- Frontend: Kill switch visible in topbar, calls /api/user/preferences
- Frontend: Socket.IO connects and invalidates queries
- Nginx: /socket.io/ proxy configured for WebSocket upgrade
</verification>

<success_criteria>
- Dashboard shows real stats from EmailEvent collection (emails processed count, per-mailbox breakdown)
- Dashboard shows pending suggestions section (empty state: "No Patterns Detected Yet")
- Activity feed shows recent email events sorted by timestamp
- Socket.IO connection established on login, events trigger dashboard refresh
- Kill switch toggle visible on every page, toggles automationPaused via /api/user/preferences
- Sidebar navigation links to dashboard, activity, patterns, rules, staging, audit, settings
- All future page routes show "Coming Soon" placeholder
- Both backend and frontend compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-shell-observation-ui/04-02-SUMMARY.md`
</output>
