---
phase: 04-frontend-shell-observation-ui
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - backend/src/config/socket.ts
  - backend/src/server.ts
  - backend/src/routes/dashboard.ts
  - backend/src/services/eventCollector.ts
  - backend/package.json
  - frontend/nginx.conf
  - frontend/src/hooks/useSocket.ts
  - frontend/src/hooks/useDashboard.ts
  - frontend/src/hooks/useKillSwitch.ts
  - frontend/src/hooks/useMailboxes.ts
  - frontend/src/api/dashboard.ts
  - frontend/src/api/mailboxes.ts
  - frontend/src/components/layout/AppShell.tsx
  - frontend/src/components/layout/AppSidebar.tsx
  - frontend/src/components/layout/Topbar.tsx
  - frontend/src/components/layout/KillSwitch.tsx
  - frontend/src/components/dashboard/StatsCards.tsx
  - frontend/src/components/dashboard/ActivityFeed.tsx
  - frontend/src/components/shared/MailboxSelector.tsx
  - frontend/src/components/shared/EmptyState.tsx
  - frontend/src/pages/DashboardPage.tsx
  - frontend/src/pages/ComingSoonPage.tsx
  - frontend/src/lib/formatters.ts
  - frontend/src/lib/constants.ts
  - frontend/src/App.tsx
autonomous: true
requirements:
  - DASH-01
  - DASH-02

must_haves:
  truths:
    - "User sees dashboard with 4 stats cards (emails processed, rules fired, patterns pending, staging count)"
    - "Dashboard shows activity feed with recent email events"
    - "User can switch between aggregate and per-mailbox views"
    - "New email events appear on dashboard within seconds via Socket.IO without page refresh"
    - "Kill switch toggle is visible in top navigation on every page"
    - "Sidebar navigation has links to all pages (dashboard, activity, patterns, rules, staging, audit, settings)"
  artifacts:
    - path: "backend/src/config/socket.ts"
      provides: "Socket.IO server with JWT cookie auth and user-scoped rooms"
      contains: "SocketServer"
    - path: "backend/src/routes/dashboard.ts"
      provides: "GET /api/dashboard/stats and GET /api/dashboard/activity endpoints"
      exports: ["dashboardRouter"]
    - path: "frontend/src/components/layout/AppShell.tsx"
      provides: "Main layout with sidebar and topbar wrapping page content"
      contains: "SidebarProvider"
    - path: "frontend/src/components/layout/KillSwitch.tsx"
      provides: "Automation pause toggle in top navigation"
      contains: "Switch"
    - path: "frontend/src/hooks/useSocket.ts"
      provides: "Socket.IO connection with TanStack Query cache invalidation"
      contains: "io("
    - path: "frontend/src/pages/DashboardPage.tsx"
      provides: "Dashboard page composing StatsCards and ActivityFeed"
      contains: "StatsCards"
    - path: "frontend/nginx.conf"
      provides: "WebSocket proxy for Socket.IO"
      contains: "socket.io"
  key_links:
    - from: "backend/src/services/eventCollector.ts"
      to: "backend/src/config/socket.ts"
      via: "getIO().to(user:userId).emit after EmailEvent save"
      pattern: "getIO.*emit.*email:event"
    - from: "backend/src/config/socket.ts"
      to: "backend/src/server.ts"
      via: "createSocketServer(app) replaces app.listen()"
      pattern: "httpServer.listen"
    - from: "frontend/src/hooks/useSocket.ts"
      to: "frontend/src/hooks/useDashboard.ts"
      via: "invalidateQueries on email:event"
      pattern: "invalidateQueries.*dashboard"
    - from: "frontend/src/pages/DashboardPage.tsx"
      to: "/api/dashboard/stats"
      via: "useDashboardStats TanStack Query hook"
      pattern: "dashboard/stats"
    - from: "frontend/src/components/layout/KillSwitch.tsx"
      to: "/api/user/preferences"
      via: "PATCH request to toggle automationPaused"
      pattern: "user/preferences"
---

<objective>
Build the app shell layout (sidebar, topbar with kill switch) and dashboard page with stats cards and activity feed, backed by new API endpoints and Socket.IO real-time updates.

Purpose: This plan delivers the core user experience -- the layout that persists across all pages and the dashboard that proves the observation pipeline is working. Socket.IO integration enables real-time visibility into email events.
Output: Working dashboard with live-updating stats and activity feed, sidebar navigation, kill switch toggle, Socket.IO server+client, and dashboard API endpoints.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-frontend-shell-observation-ui/04-RESEARCH.md
@.planning/phases/04-frontend-shell-observation-ui/04-01-SUMMARY.md
@backend/src/server.ts
@backend/src/config/index.ts
@backend/src/services/eventCollector.ts
@backend/src/auth/middleware.ts
@backend/src/models/EmailEvent.ts
@backend/src/models/User.ts
@backend/src/models/Mailbox.ts
@frontend/nginx.conf
@frontend/src/App.tsx
@frontend/src/stores/authStore.ts
@frontend/src/stores/uiStore.ts
@frontend/src/api/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Socket.IO server, dashboard API endpoints, and event emission wiring</name>
  <files>
    backend/src/config/socket.ts
    backend/src/server.ts
    backend/src/routes/dashboard.ts
    backend/src/services/eventCollector.ts
    backend/package.json
    frontend/nginx.conf
  </files>
  <action>
1. Install Socket.IO on the backend:
   ```
   cd backend && npm install socket.io
   ```

2. Create `backend/src/config/socket.ts` -- Socket.IO server with JWT cookie auth:
   - Export `createSocketServer(app: Express)` that returns `{ httpServer, io }`
   - Create HTTP server with `createServer(app)`
   - Create Socket.IO server attached to httpServer with CORS origin from config.appUrl, credentials: true
   - io.use() middleware: parse cookies from socket.handshake.headers.cookie, extract msedb_session cookie, verify JWT with jwt.verify(token, config.jwtSecret), store decoded user in socket.data.user
   - io.on('connection'): join `user:${userId}` room, log connection, handle disconnect
   - Export `getIO()` function that returns the io instance (stored in module-level variable, throws if not initialized)
   - CRITICAL: Use the simple cookie parsing from research (split by ';', split by '='). Do NOT import cookie-parser for this -- it's handshake headers, not Express middleware.

3. Modify `backend/src/server.ts`:
   - Import createSocketServer from ./config/socket.js
   - CRITICAL CHANGE: Replace `app.listen(config.port, ...)` with:
     ```typescript
     const { httpServer, io } = createSocketServer(app);
     httpServer.listen(config.port, () => { ... });
     ```
   - Store io on app for potential health check access: `app.set('io', io)`
   - Keep all existing middleware, routes, and startup sequence EXACTLY as-is. Only change the listen() call.
   - Mount dashboardRouter at '/api/dashboard'

4. Create `backend/src/routes/dashboard.ts` with requireAuth middleware:
   - GET /stats: Returns { emailsProcessed, rulesFired: 0, patternsPending: 0, stagingCount: 0, perMailbox: [...] }
     - emailsProcessed = EmailEvent.countDocuments({ userId })
     - perMailbox = EmailEvent.aggregate group by mailboxId with count
     - Join mailbox info (email, displayName) from Mailbox model
     - Optional ?mailboxId query param for per-mailbox filtering
   - GET /activity: Returns { events: [...] }
     - Find EmailEvent for userId, sorted by timestamp desc, limited to 50 (configurable via ?limit, max 200)
     - Select: eventType, sender, subject, timestamp, mailboxId, fromFolder, toFolder
     - Optional ?mailboxId query param
   - PATCH /user/preferences: Accepts { automationPaused: boolean }, updates User.preferences.automationPaused, returns updated preferences
     - This endpoint handles the kill switch toggle
     - Note: Mount this as a separate route `/api/user` if cleaner, but it can live in dashboard router for now

5. Modify `backend/src/services/eventCollector.ts`:
   - Import getIO from '../config/socket.js'
   - After a successful EmailEvent save (after the document is persisted to MongoDB), emit a Socket.IO event:
     ```typescript
     try {
       const io = getIO();
       io.to(`user:${userId}`).emit('email:event', {
         id: savedEvent._id,
         eventType: savedEvent.eventType,
         sender: savedEvent.sender,
         subject: savedEvent.subject,
         timestamp: savedEvent.timestamp,
         mailboxId: savedEvent.mailboxId,
       });
     } catch {
       // Socket.IO not initialized (e.g., during tests) -- ignore silently
     }
     ```
   - Wrap in try/catch so Socket.IO failures never break event collection.

6. Update `frontend/nginx.conf` -- add Socket.IO proxy location block BEFORE the SPA catch-all:
   ```nginx
   location /socket.io/ {
       proxy_pass http://msedb-backend:8010/socket.io/;
       proxy_http_version 1.1;
       proxy_set_header Upgrade $http_upgrade;
       proxy_set_header Connection "upgrade";
       proxy_set_header Host $host;
       proxy_set_header X-Real-IP $remote_addr;
       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
       proxy_set_header X-Forwarded-Proto $scheme;
       proxy_read_timeout 86400s;
       proxy_send_timeout 86400s;
   }
   ```

7. Verify backend compiles: `cd backend && npx tsc --noEmit`
  </action>
  <verify>
    - `cd backend && npx tsc --noEmit` compiles without errors
    - `grep -r "httpServer.listen" backend/src/server.ts` confirms Socket.IO integration
    - `grep -r "getIO" backend/src/services/eventCollector.ts` confirms event emission
    - `grep -r "socket.io" frontend/nginx.conf` confirms WebSocket proxy
    - backend/src/config/socket.ts exists
    - backend/src/routes/dashboard.ts exists
  </verify>
  <done>
    - Socket.IO server attached to HTTP server with JWT cookie auth and user-scoped rooms
    - server.ts uses httpServer.listen instead of app.listen
    - Dashboard stats and activity endpoints return real EmailEvent data
    - Kill switch endpoint (PATCH /api/user/preferences) updates User.preferences
    - Event collector emits Socket.IO events after EmailEvent saves
    - Nginx proxies /socket.io/ WebSocket connections to backend
    - Backend compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: App shell layout, dashboard page, Socket.IO hook, and frontend wiring</name>
  <files>
    frontend/src/hooks/useSocket.ts
    frontend/src/hooks/useDashboard.ts
    frontend/src/hooks/useKillSwitch.ts
    frontend/src/hooks/useMailboxes.ts
    frontend/src/api/dashboard.ts
    frontend/src/api/mailboxes.ts
    frontend/src/components/layout/AppShell.tsx
    frontend/src/components/layout/AppSidebar.tsx
    frontend/src/components/layout/Topbar.tsx
    frontend/src/components/layout/KillSwitch.tsx
    frontend/src/components/dashboard/StatsCards.tsx
    frontend/src/components/dashboard/ActivityFeed.tsx
    frontend/src/components/shared/MailboxSelector.tsx
    frontend/src/components/shared/EmptyState.tsx
    frontend/src/pages/DashboardPage.tsx
    frontend/src/pages/ComingSoonPage.tsx
    frontend/src/lib/formatters.ts
    frontend/src/lib/constants.ts
    frontend/src/App.tsx
  </files>
  <action>
1. Create `frontend/src/lib/constants.ts`:
   - EVENT_TYPES: Record of event type labels and colors (arrived=blue, deleted=red, moved=yellow, read=green, flagged=purple, categorized=indigo)
   - ROUTE_PATHS: { dashboard: '/', activity: '/activity', patterns: '/patterns', rules: '/rules', staging: '/staging', audit: '/audit', settings: '/settings', login: '/login' }
   - NAV_ITEMS: Array of { label, path, icon (lucide icon name) } for sidebar navigation

2. Create `frontend/src/lib/formatters.ts`:
   - `formatRelativeTime(date: string | Date): string` -- uses date-fns formatDistanceToNow with addSuffix: true
   - `formatNumber(n: number): string` -- n.toLocaleString()
   - `formatEmail(email?: string): string` -- truncate long emails, handle undefined
   - `formatEventType(type: string): string` -- capitalize and humanize event type names

3. Create `frontend/src/api/dashboard.ts`:
   - `fetchDashboardStats(mailboxId?: string)` -- GET /dashboard/stats?mailboxId=
   - `fetchDashboardActivity(mailboxId?: string, limit?: number)` -- GET /dashboard/activity?mailboxId=&limit=
   - `updatePreferences(prefs: { automationPaused: boolean })` -- PATCH /user/preferences (or /dashboard/user/preferences depending on Task 1 mount point)

4. Create `frontend/src/api/mailboxes.ts`:
   - `fetchMailboxes()` -- GET /mailboxes (already exists from Phase 2's mailbox router which has GET / for listing)

5. Create `frontend/src/hooks/useSocket.ts`:
   - Connect to Socket.IO on mount with `io({ withCredentials: true })` -- no URL needed, defaults to same origin
   - Listen for 'email:event' -- invalidate ['dashboard'] and ['events'] query keys
   - Listen for 'connect_error' -- log to console
   - Return socket ref
   - Cleanup: disconnect on unmount
   - IMPORTANT: Create socket connection exactly ONCE. Use useRef to prevent reconnection on re-renders.

6. Create `frontend/src/hooks/useDashboard.ts`:
   - `useDashboardStats(mailboxId?: string | null)` -- useQuery with key ['dashboard', 'stats', mailboxId], calls fetchDashboardStats
   - `useDashboardActivity(mailboxId?: string | null)` -- useQuery with key ['dashboard', 'activity', mailboxId], calls fetchDashboardActivity

7. Create `frontend/src/hooks/useKillSwitch.ts`:
   - useMutation calling updatePreferences({ automationPaused })
   - On success: update authStore.user.preferences.automationPaused optimistically
   - Invalidate dashboard queries on success

8. Create `frontend/src/hooks/useMailboxes.ts`:
   - useQuery with key ['mailboxes'], calls fetchMailboxes
   - Return { mailboxes, isLoading }

9. Create `frontend/src/components/shared/EmptyState.tsx`:
   - Accepts title, description, icon (LucideIcon) props
   - Renders centered icon + text in muted colors

10. Create `frontend/src/components/shared/MailboxSelector.tsx`:
    - Select dropdown showing "All Mailboxes" + list of connected mailboxes from authStore.mailboxes
    - On change: update uiStore.selectedMailboxId
    - Use shadcn Select component

11. Create `frontend/src/components/layout/KillSwitch.tsx`:
    - shadcn Switch component showing automation state
    - Label: "Automation" with small status indicator (green=active, red=paused)
    - Toggle calls useKillSwitch mutation
    - Reads automationPaused from authStore.user.preferences
    - IMPORTANT: This is prominent (not hidden) per SAFE-02 requirements -- visible on every page

12. Create `frontend/src/components/layout/Topbar.tsx`:
    - Horizontal bar at top of content area
    - Left: SidebarTrigger (hamburger) for mobile, breadcrumb or page title
    - Center/Right: MailboxSelector, KillSwitch, user avatar with dropdown menu (shows email, logout option)
    - Use shadcn DropdownMenu for user menu, Avatar component

13. Create `frontend/src/components/layout/AppSidebar.tsx`:
    - Use shadcn Sidebar component
    - Logo/title at top: "MSEDB" with mail icon
    - Navigation items from NAV_ITEMS constant with lucide icons:
      - Dashboard (LayoutDashboard)
      - Email Activity (Mail)
      - Patterns (Brain)
      - Rules (Shield)
      - Staging (Clock)
      - Audit Log (FileText)
      - Settings (Settings)
    - Use NavLink from react-router for active state highlighting
    - Collapsible on mobile

14. Create `frontend/src/components/layout/AppShell.tsx`:
    - Wraps content in shadcn SidebarProvider + SidebarInset
    - Renders AppSidebar + Topbar + main content area (children/Outlet)
    - Full height layout with sidebar on left, content on right

15. Create `frontend/src/components/dashboard/StatsCards.tsx`:
    - 4 cards in a responsive grid (1 col mobile, 2 cols md, 4 cols lg)
    - Cards: Emails Processed (Mail icon, blue), Rules Fired (Shield, green), Patterns Pending (Brain, yellow), In Staging (Clock, orange)
    - Each card shows formatted number value
    - Use shadcn Card component
    - Accept props: { emailsProcessed, rulesFired, patternsPending, stagingCount }

16. Create `frontend/src/components/dashboard/ActivityFeed.tsx`:
    - Scrollable list of recent email events using shadcn ScrollArea
    - Each item shows: event type badge (colored), sender email, subject (truncated), relative timestamp
    - Empty state when no events
    - Use shadcn Badge for event types with colors from constants
    - Accept props: { events: Array<{ eventType, sender, subject, timestamp, mailboxId }> }

17. Create `frontend/src/pages/DashboardPage.tsx`:
    - Uses useDashboardStats and useDashboardActivity hooks with uiStore.selectedMailboxId
    - Renders StatsCards with stats data
    - Renders ActivityFeed with activity data
    - Loading skeletons while data loads (shadcn Skeleton)
    - Error states with EmptyState component

18. Create `frontend/src/pages/ComingSoonPage.tsx`:
    - Accepts title prop
    - Shows centered "Coming Soon" message with the page title
    - Used for placeholder routes (patterns, rules, staging, audit, settings)

19. Update `frontend/src/App.tsx`:
    - Wrap ProtectedLayout in AppShell (import from Plan 02 layout components)
    - Initialize Socket.IO via useSocket() hook inside ProtectedLayout (only connect when authenticated)
    - Replace placeholder route elements with DashboardPage, ComingSoonPage, etc.
    - Keep existing router structure, just update the components

20. Verify: `cd frontend && npx tsc -b && npx vite build`
  </action>
  <verify>
    - `cd frontend && npx tsc -b` compiles without errors
    - `cd frontend && npx vite build` produces dist/ output
    - All layout files exist: AppShell.tsx, AppSidebar.tsx, Topbar.tsx, KillSwitch.tsx
    - All dashboard files exist: StatsCards.tsx, ActivityFeed.tsx, DashboardPage.tsx
    - All hook files exist: useSocket.ts, useDashboard.ts, useKillSwitch.ts, useMailboxes.ts
    - All API files exist: dashboard.ts, mailboxes.ts
    - `grep -r "useSocket" frontend/src/App.tsx` confirms Socket.IO initialization
    - `grep -r "AppShell" frontend/src/App.tsx` confirms layout integration
  </verify>
  <done>
    - App shell renders sidebar navigation with links to all 7 pages
    - Topbar shows mailbox selector, kill switch toggle, and user menu on every page
    - Dashboard page displays 4 stats cards with data from /api/dashboard/stats
    - Activity feed shows recent email events from /api/dashboard/activity
    - Mailbox selector switches between aggregate and per-mailbox views
    - Socket.IO connects on authentication and invalidates dashboard queries on email:event
    - Kill switch toggles User.preferences.automationPaused via API
    - Placeholder pages render "Coming Soon" for unbuilt features
    - TypeScript compiles and Vite builds successfully
  </done>
</task>

</tasks>

<verification>
- `cd backend && npx tsc --noEmit` passes
- `cd frontend && npx tsc -b && npx vite build` passes
- Backend: Socket.IO server initializes with JWT cookie auth
- Backend: Dashboard stats/activity endpoints query EmailEvent model
- Backend: Event collector emits Socket.IO events after saves
- Frontend: Dashboard page renders stats cards and activity feed
- Frontend: Sidebar has navigation to all pages
- Frontend: Kill switch visible in topbar
- Frontend: Socket.IO connects and invalidates queries
- Nginx: /socket.io/ proxy configured for WebSocket upgrade
</verification>

<success_criteria>
- Dashboard shows real stats from EmailEvent collection (emails processed count, per-mailbox breakdown)
- Activity feed shows recent email events sorted by timestamp
- Socket.IO connection established on login, events trigger dashboard refresh
- Kill switch toggle visible on every page, toggles automationPaused preference
- Sidebar navigation links to dashboard, activity, patterns, rules, staging, audit, settings
- All future page routes show "Coming Soon" placeholder
- Both backend and frontend compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-shell-observation-ui/04-02-SUMMARY.md`
</output>
