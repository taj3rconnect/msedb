---
phase: 06-automation-safety
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - backend/src/routes/rules.ts
  - backend/src/routes/staging.ts
  - backend/src/routes/audit.ts
  - backend/src/routes/mailbox.ts
  - backend/src/server.ts
autonomous: true
requirements: [AUTO-02, SAFE-04, SAFE-05]

must_haves:
  truths:
    - "Rules CRUD API supports create, read, update, delete, reorder, and enable/disable"
    - "Staging API lists staged emails and supports rescue and batch rescue"
    - "Audit API returns paginated, filterable history with undo endpoint"
    - "Whitelist endpoints allow per-mailbox sender/domain management"
  artifacts:
    - path: "backend/src/routes/rules.ts"
      provides: "Rules CRUD + reorder + enable/disable + stats"
      exports: ["rulesRouter"]
    - path: "backend/src/routes/staging.ts"
      provides: "Staging list, rescue, batch rescue"
      exports: ["stagingRouter"]
    - path: "backend/src/routes/audit.ts"
      provides: "Audit log list with filters + undo endpoint"
      exports: ["auditRouter"]
  key_links:
    - from: "backend/src/routes/rules.ts"
      to: "backend/src/services/ruleConverter.ts"
      via: "POST /rules/from-pattern calls convertPatternToRule"
      pattern: "convertPatternToRule"
    - from: "backend/src/routes/audit.ts"
      to: "backend/src/services/undoService.ts"
      via: "POST /audit/:id/undo calls undoAction"
      pattern: "undoAction"
    - from: "backend/src/server.ts"
      to: "all new routers"
      via: "app.use mount points"
      pattern: "app\\.use.*Router"
---

<objective>
Build REST API routes for rules, staging, audit, and whitelist management -- the API layer consumed by the frontend pages.

Purpose: The frontend needs CRUD endpoints for all automation features. This plan creates the Express routers that expose the services built in Plans 01-02 via REST API, plus mounts them in server.ts.

Output: Four route files (rules, staging, audit, mailbox whitelist update) and server.ts updates.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-automation-safety/06-RESEARCH.md
@.planning/phases/06-automation-safety/06-01-SUMMARY.md
@.planning/phases/06-automation-safety/06-02-SUMMARY.md

@backend/src/server.ts
@backend/src/routes/patterns.ts
@backend/src/routes/events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rules CRUD API and whitelist endpoints</name>
  <files>
    backend/src/routes/rules.ts
    backend/src/routes/mailbox.ts
  </files>
  <action>
    **1. Create `backend/src/routes/rules.ts`:**
    - Follow the same router pattern as patterns.ts -- `const rulesRouter = Router(); rulesRouter.use(requireAuth);`
    - Import Rule, AuditLog models, convertPatternToRule from services, NotFoundError/ValidationError from errorHandler

    **GET /api/rules** -- List rules for current user
    - Query params: `mailboxId` (optional filter), `page` (default 1), `limit` (default 50, max 100)
    - Filter by userId, optionally by mailboxId
    - Sort by `priority: 1` (ascending -- lower number = higher priority)
    - Return `{ rules, pagination: { page, limit, total, totalPages } }`

    **POST /api/rules** -- Create a manual rule (not from pattern)
    - Body: `{ mailboxId, name, conditions, actions }` -- validate all required fields
    - Validate name is non-empty string
    - Validate mailboxId exists and belongs to user
    - Validate at least one condition and one action
    - Calculate priority: find max priority for user+mailbox, add 1
    - Create Rule document, create AuditLog 'rule_created'
    - Return 201 with `{ rule }`

    **POST /api/rules/from-pattern** -- Convert approved pattern to rule (AUTO-04)
    - Body: `{ patternId }`
    - Call `convertPatternToRule(patternId, userId)`
    - Return 201 with `{ rule }`

    **PUT /api/rules/:id** -- Update rule (name, conditions, actions, isEnabled)
    - Find rule by id and userId. Throw NotFoundError if missing.
    - Update allowed fields only: name, conditions, actions
    - Create AuditLog 'rule_updated' with before/after
    - Return `{ rule }`

    **PATCH /api/rules/:id/toggle** -- Enable/disable rule
    - Find rule by id and userId
    - Toggle `isEnabled` to opposite value
    - Create AuditLog 'rule_updated' with `{ toggled: true, isEnabled: newValue }`
    - Return `{ rule }`

    **PUT /api/rules/reorder** -- Reorder rules by priority (drag-and-drop)
    - Body: `{ mailboxId, ruleIds: string[] }` -- ordered array of rule IDs
    - Validate all ruleIds belong to user and mailboxId
    - Use `bulkWrite` with `updateOne` operations: set `priority` to array index for each rule
    - This is an atomic reorder -- all priorities updated in one operation
    - Return `{ success: true }`

    **DELETE /api/rules/:id** -- Delete rule
    - Find rule by id and userId. Throw NotFoundError if missing.
    - Delete the rule
    - Create AuditLog 'rule_deleted' with rule details
    - Return `{ success: true }`

    **2. Add whitelist endpoints to `backend/src/routes/mailbox.ts`:**
    - Add to the existing mailbox router (already has requireAuth)
    - Import `addToOrgWhitelist`, `removeFromOrgWhitelist`, `getOrgWhitelist` from whitelistService
    - Import requireAdmin from auth middleware

    **GET /api/mailboxes/:id/whitelist** -- Get per-mailbox whitelist
    - Find mailbox by id and userId
    - Return `{ senders: mailbox.settings.whitelistedSenders, domains: mailbox.settings.whitelistedDomains }`

    **PUT /api/mailboxes/:id/whitelist** -- Update per-mailbox whitelist
    - Body: `{ senders?: string[], domains?: string[] }`
    - Update `mailbox.settings.whitelistedSenders` and/or `mailbox.settings.whitelistedDomains`
    - Create AuditLog 'whitelist_updated' with targetType 'settings'
    - Return updated whitelist

    **GET /api/mailboxes/org-whitelist** -- Get org-wide whitelist (admin only)
    - requireAdmin middleware
    - Call `getOrgWhitelist()` from whitelistService
    - Return `{ senders, domains }`

    **PUT /api/mailboxes/org-whitelist** -- Update org-wide whitelist (admin only)
    - requireAdmin middleware
    - Body: `{ senders?: string[], domains?: string[] }`
    - Call appropriate add/remove functions
    - Return updated whitelist

    NOTE: The org-whitelist routes MUST be defined before `/:id` routes on the mailbox router to avoid '/' being captured as an :id.

    Export `{ rulesRouter }` from rules.ts.
  </action>
  <verify>
    Run `npx tsc --noEmit` from backend directory.
    Verify rules.ts exports rulesRouter with all 7 endpoints.
    Verify mailbox.ts has whitelist endpoints added.
  </verify>
  <done>
    Rules CRUD API with priority reorder, enable/disable toggle, and pattern-to-rule conversion.
    Whitelist endpoints for per-mailbox and org-wide management.
    All mutations create AuditLog entries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Staging and audit API routes, mount all routers</name>
  <files>
    backend/src/routes/staging.ts
    backend/src/routes/audit.ts
    backend/src/server.ts
  </files>
  <action>
    **1. Create `backend/src/routes/staging.ts`:**
    - Follow router pattern: `const stagingRouter = Router(); stagingRouter.use(requireAuth);`
    - Import StagedEmail, rescueStagedEmail, batchRescueStagedEmails from stagingManager

    **GET /api/staging** -- List staged emails
    - Query params: `mailboxId` (optional), `status` (default 'staged'), `page`, `limit`
    - Filter by userId, optionally mailboxId, status
    - Sort by `expiresAt: 1` (soonest to expire first)
    - Return `{ stagedEmails, pagination }`

    **GET /api/staging/count** -- Get count of active staged emails (for badge)
    - Count where userId matches and status is 'staged'
    - Optionally filter by mailboxId
    - Return `{ count }`

    **POST /api/staging/:id/rescue** -- Rescue a single staged email
    - Call `rescueStagedEmail(id, userId)`
    - Return `{ stagedEmail }`

    **POST /api/staging/batch-rescue** -- Batch rescue
    - Body: `{ ids: string[] }`
    - Call `batchRescueStagedEmails(ids, userId)`
    - Return `{ rescued: count }`

    **2. Create `backend/src/routes/audit.ts`:**
    - Follow router pattern: `const auditRouter = Router(); auditRouter.use(requireAuth);`
    - Import AuditLog, undoAction from undoService

    **GET /api/audit** -- Paginated audit log with filters
    - Query params: `mailboxId`, `ruleId`, `action` (comma-separated), `startDate`, `endDate`, `page`, `limit`
    - Build filter: userId (always), plus optional mailboxId, action type ($in if comma-separated), createdAt range ($gte/$lte)
    - If `ruleId` provided, filter by `details.ruleId` or `targetId` matching ruleId
    - Sort by `createdAt: -1` (newest first)
    - Return `{ auditLogs, pagination }`

    **POST /api/audit/:id/undo** -- Undo an automated action
    - Call `undoAction(id, userId)`
    - Return `{ auditLog }`

    **3. Update `backend/src/server.ts`:**
    - Import `{ rulesRouter }` from `./routes/rules.js`
    - Import `{ stagingRouter }` from `./routes/staging.js`
    - Import `{ auditRouter }` from `./routes/audit.js`
    - Mount routes after the patterns router:
      ```
      app.use('/api/rules', rulesRouter);
      app.use('/api/staging', stagingRouter);
      app.use('/api/audit', auditRouter);
      ```
    - Place these BEFORE the global error handler
  </action>
  <verify>
    Run `npx tsc --noEmit` from backend directory.
    Verify staging.ts exports stagingRouter.
    Verify audit.ts exports auditRouter.
    Verify server.ts imports and mounts all three new routers.
    Verify mount order: new routers before globalErrorHandler.
  </verify>
  <done>
    Staging API with list, count, rescue, and batch rescue endpoints.
    Audit API with paginated, filterable history and undo endpoint.
    All three new routers mounted in server.ts at /api/rules, /api/staging, /api/audit.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes from backend/
- 3 new route files exist (rules.ts, staging.ts, audit.ts)
- server.ts mounts all 3 new routers before error handler
- Mailbox router has 4 new whitelist endpoints
- All CRUD operations create appropriate AuditLog entries
</verification>

<success_criteria>
- Rules API supports full CRUD with reorder, toggle, and pattern conversion
- Staging API supports list with count, rescue, and batch rescue
- Audit API supports filtered pagination and undo
- Whitelist API supports per-mailbox and org-wide management
- All routes require authentication
</success_criteria>

<output>
After completion, create `.planning/phases/06-automation-safety/06-03-SUMMARY.md`
</output>
