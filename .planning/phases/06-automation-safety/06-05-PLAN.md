---
phase: 06-automation-safety
plan: 05
type: execute
wave: 3
depends_on: ["06-03"]
files_modified:
  - frontend/src/api/rules.ts
  - frontend/src/hooks/useRules.ts
  - frontend/src/components/rules/RuleCard.tsx
  - frontend/src/components/rules/RuleList.tsx
  - frontend/src/pages/RulesPage.tsx
  - frontend/src/App.tsx
  - frontend/package.json
autonomous: true
requirements: [PAGE-03]

must_haves:
  truths:
    - "Rules page shows all rules with per-rule execution stats"
    - "Rules can be reordered via drag-and-drop for priority"
    - "Rules can be enabled/disabled via toggle"
    - "Rules page supports per-mailbox filtering"
  artifacts:
    - path: "frontend/src/pages/RulesPage.tsx"
      provides: "Rules page replacing ComingSoonPage"
      contains: "DndContext"
    - path: "frontend/src/components/rules/RuleList.tsx"
      provides: "Sortable rule list with dnd-kit"
      contains: "SortableContext"
    - path: "frontend/src/components/rules/RuleCard.tsx"
      provides: "Individual rule display with stats and toggle"
      contains: "useSortable"
  key_links:
    - from: "frontend/src/pages/RulesPage.tsx"
      to: "/api/rules"
      via: "TanStack Query hooks"
      pattern: "useRules"
    - from: "frontend/src/components/rules/RuleList.tsx"
      to: "/api/rules/reorder"
      via: "PUT on drag end"
      pattern: "reorder"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/pages/RulesPage.tsx"
      via: "route /rules"
      pattern: "RulesPage"
---

<objective>
Build the Rules page with drag-and-drop reordering using @dnd-kit, per-rule execution stats, and enable/disable toggles -- replacing the ComingSoonPage placeholder.

Purpose: Users need to see their automation rules, reorder priorities via drag-and-drop, toggle rules on/off, and view execution statistics. This is the primary rule management interface.

Output: Rules page with dnd-kit sortable list, API client, TanStack Query hooks, and route update.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-automation-safety/06-RESEARCH.md
@.planning/phases/06-automation-safety/06-03-SUMMARY.md

@frontend/src/App.tsx
@frontend/src/pages/PatternsPage.tsx
@frontend/src/api/patterns.ts
@frontend/src/hooks/usePatterns.ts
@frontend/src/components/patterns/PatternCard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dnd-kit, create API client and hooks</name>
  <files>
    frontend/package.json
    frontend/src/api/rules.ts
    frontend/src/hooks/useRules.ts
  </files>
  <action>
    **1. Install dnd-kit dependencies:**
    - Run from frontend directory: `npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities`

    **2. Create `frontend/src/api/rules.ts`:**
    - Follow the pattern from `frontend/src/api/patterns.ts`
    - Import `apiFetch` from `./client`
    - Define `Rule` interface matching backend IRule (id, name, conditions, actions, isEnabled, priority, stats, mailboxId, sourcePatternId, createdAt, updatedAt)
    - Define `RulesResponse` = `{ rules: Rule[]; pagination: { page, limit, total, totalPages } }`

    Export functions:
    - `fetchRules(params: { mailboxId?, page?, limit? }): Promise<RulesResponse>` -- GET /api/rules with query params
    - `createRuleFromPattern(patternId: string): Promise<{ rule: Rule }>` -- POST /api/rules/from-pattern
    - `createRule(data: { mailboxId, name, conditions, actions }): Promise<{ rule: Rule }>` -- POST /api/rules
    - `updateRule(id: string, data: Partial<Rule>): Promise<{ rule: Rule }>` -- PUT /api/rules/:id
    - `toggleRule(id: string): Promise<{ rule: Rule }>` -- PATCH /api/rules/:id/toggle
    - `reorderRules(mailboxId: string, ruleIds: string[]): Promise<void>` -- PUT /api/rules/reorder
    - `deleteRule(id: string): Promise<void>` -- DELETE /api/rules/:id

    **3. Create `frontend/src/hooks/useRules.ts`:**
    - Follow the pattern from `frontend/src/hooks/usePatterns.ts`
    - Import `useQuery`, `useMutation`, `useQueryClient` from `@tanstack/react-query`
    - Import all API functions from `@/api/rules`
    - Import `useUIStore` for selectedMailboxId

    Export hooks:
    - `useRules(params?: { mailboxId?, page?, limit? })` -- useQuery with key ['rules', params], fetches rules
    - `useCreateRuleFromPattern()` -- useMutation calling createRuleFromPattern, invalidates ['rules'] on success
    - `useToggleRule()` -- useMutation calling toggleRule, invalidates ['rules'] on success
    - `useReorderRules()` -- useMutation calling reorderRules, invalidates ['rules'] on success
    - `useDeleteRule()` -- useMutation calling deleteRule, invalidates ['rules'] on success
  </action>
  <verify>
    Run `npm install` verification: check that @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities are in package.json dependencies.
    Run `npx tsc --noEmit` from frontend directory.
    Verify rules.ts and useRules.ts exist with correct exports.
  </verify>
  <done>
    dnd-kit installed for React 19 compatible drag-and-drop.
    Rules API client matches backend endpoints.
    TanStack Query hooks provide data fetching and mutations with cache invalidation.
  </done>
</task>

<task type="auto">
  <name>Task 2: RuleCard, RuleList, and RulesPage components</name>
  <files>
    frontend/src/components/rules/RuleCard.tsx
    frontend/src/components/rules/RuleList.tsx
    frontend/src/pages/RulesPage.tsx
    frontend/src/App.tsx
  </files>
  <action>
    **1. Create `frontend/src/components/rules/RuleCard.tsx`:**
    - Import `useSortable` from `@dnd-kit/sortable`, `CSS` from `@dnd-kit/utilities`
    - Import shadcn components: Card, CardContent, Switch, Badge, Button
    - Import `GripVertical, Trash2, Pencil` from `lucide-react`
    - Import `Rule` type from `@/api/rules`

    Props: `{ rule: Rule; onToggle: (id: string) => void; onDelete: (id: string) => void }`

    - Use `useSortable({ id: rule._id || rule.id })` for drag-and-drop -- apply `setNodeRef`, `transform`, `transition` to the outer Card div, spread `attributes` on the card
    - Apply `{...listeners}` ONLY to the GripVertical icon (drag handle, not entire card)
    - Display: drag handle (GripVertical icon) | rule name | conditions summary (e.g., "From: sender@email.com") | actions summary (e.g., "Move to Archive, Mark Read") | stats (total executions, last executed date) | enabled/disabled Switch | delete button
    - Stats display: "X executions" badge, "Last: {relative date}" if lastExecutedAt exists
    - Conditions: show senderEmail, senderDomain, subjectContains, fromFolder as small badges
    - Actions: show each action as a colored badge (move=blue, delete=red, markRead=green, categorize=purple, archive=yellow, flag=orange)
    - Switch component for isEnabled with onCheckedChange calling onToggle
    - Style with Tailwind: `cursor-grab` on drag handle, `opacity-50` when disabled

    **2. Create `frontend/src/components/rules/RuleList.tsx`:**
    - Import `DndContext`, `closestCenter`, `type DragEndEvent`, `KeyboardSensor`, `PointerSensor`, `useSensor`, `useSensors` from `@dnd-kit/core`
    - Import `SortableContext`, `verticalListSortingStrategy`, `arrayMove` from `@dnd-kit/sortable`
    - Import `restrictToVerticalAxis` from `@dnd-kit/modifiers` (comes with @dnd-kit/core)
    - Import `RuleCard` from `./RuleCard`
    - Import `Rule` type

    Props: `{ rules: Rule[]; onToggle, onDelete, onReorder: (mailboxId: string, ruleIds: string[]) => void }`

    - Set up sensors: `useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor))`
    - Maintain local rules state for optimistic reorder
    - On `handleDragEnd`: use `arrayMove` to reorder, call `onReorder` with new order of IDs
    - Wrap in `<DndContext>` with `<SortableContext items={ruleIds} strategy={verticalListSortingStrategy}>`
    - Render RuleCard for each rule
    - Show empty state if no rules

    **3. Create `frontend/src/pages/RulesPage.tsx`:**
    - Import useRules, useToggleRule, useDeleteRule, useReorderRules hooks
    - Import RuleList component
    - Import `useUIStore` for selectedMailboxId
    - Import shadcn components for page layout
    - Import `MailboxSelector` if it exists (or filter dropdown)

    Layout:
    - Page header: "Rules" title, per-mailbox filter dropdown (use existing selectedMailboxId from UI store)
    - If no mailbox selected, show "Select a mailbox to view rules"
    - RuleList component with rules data from useRules hook
    - Pagination at bottom if many rules
    - Loading state while fetching
    - Empty state: "No rules yet. Approve a pattern to create your first rule."
    - Wire up toggle, delete, and reorder mutations

    **4. Update `frontend/src/App.tsx`:**
    - Import `RulesPage` from `@/pages/RulesPage`
    - Replace `<ComingSoonPage title="Rules" />` with `<RulesPage />`
    - Keep the route path as `/rules`
  </action>
  <verify>
    Run `npx tsc --noEmit` from frontend directory.
    Verify RulesPage.tsx imports and uses DndContext/SortableContext.
    Verify App.tsx routes /rules to RulesPage (not ComingSoonPage).
    Verify RuleCard.tsx uses useSortable hook.
  </verify>
  <done>
    Rules page shows rules sorted by priority with drag-and-drop reordering.
    Each rule card shows conditions, actions, execution stats, and enable/disable toggle.
    Drag handle on left side of each card for priority reordering.
    Per-mailbox filtering via mailbox selector.
    Route /rules in App.tsx points to RulesPage (not ComingSoonPage).
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes from frontend/
- dnd-kit packages in package.json
- Rules page renders with drag-and-drop sortable list
- App.tsx routes /rules to RulesPage
- RuleCard shows stats, conditions, actions, toggle
</verification>

<success_criteria>
- Rules page replaces ComingSoonPage with full rule management UI
- Drag-and-drop reordering works with @dnd-kit (React 19 compatible)
- Per-rule execution stats visible (total executions, last executed)
- Enable/disable toggle works per rule
- Per-mailbox filtering via existing mailbox selector pattern
</success_criteria>

<output>
After completion, create `.planning/phases/06-automation-safety/06-05-SUMMARY.md`
</output>
