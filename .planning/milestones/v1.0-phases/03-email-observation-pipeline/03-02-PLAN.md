---
phase: 03-email-observation-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/src/services/metadataExtractor.ts
  - backend/src/services/eventCollector.ts
  - backend/src/jobs/processors/webhookEvents.ts
  - backend/src/jobs/queues.ts
autonomous: true
requirements: [OBSV-03, OBSV-04]

must_haves:
  truths:
    - "Webhook notifications are processed into EmailEvent documents with correct metadata"
    - "Sender email, domain, subject, folder, timestamp, and importance are extracted from Graph messages"
    - "Message moves between folders are detected by comparing parentFolderId against last known state"
    - "Duplicate events are silently skipped via MongoDB compound unique index (error code 11000)"
    - "Email body content is never fetched or stored"
    - "Newsletter and automated email indicators are detected from internet message headers"
  artifacts:
    - path: "backend/src/services/metadataExtractor.ts"
      provides: "Extract metadata from Graph message objects into EmailEvent shape"
      exports: ["extractMetadata", "GraphMessage"]
    - path: "backend/src/services/eventCollector.ts"
      provides: "Fetch message details from Graph, process into deduplicated EmailEvent documents"
      exports: ["processChangeNotification", "saveEmailEvent"]
    - path: "backend/src/jobs/processors/webhookEvents.ts"
      provides: "BullMQ processor that handles incoming change notifications"
      exports: ["processWebhookEvent"]
  key_links:
    - from: "backend/src/jobs/processors/webhookEvents.ts"
      to: "backend/src/services/eventCollector.ts"
      via: "processChangeNotification call"
      pattern: "processChangeNotification"
    - from: "backend/src/services/eventCollector.ts"
      to: "backend/src/services/graphClient.ts"
      via: "graphFetch to get message details"
      pattern: "graphFetch"
    - from: "backend/src/services/eventCollector.ts"
      to: "backend/src/services/metadataExtractor.ts"
      via: "extractMetadata call"
      pattern: "extractMetadata"
    - from: "backend/src/services/eventCollector.ts"
      to: "backend/src/models/EmailEvent.ts"
      via: "EmailEvent.create with duplicate key error handling"
      pattern: "EmailEvent\\.create|code === 11000"
---

<objective>
Build the event processing pipeline that turns webhook notifications into stored EmailEvent documents. When a notification arrives via BullMQ, fetch the message details from Graph API, extract metadata (sender, subject, folder, timestamps -- never body content), detect move operations, and store deduplicated EmailEvent documents in MongoDB.

Purpose: This is the data extraction layer -- the bridge between raw Graph notifications and structured event data that the pattern intelligence engine (Phase 5) will analyze. Without reliable metadata extraction and deduplication, the entire downstream pipeline has bad data.

Output: metadataExtractor.ts, eventCollector.ts, webhookEvents.ts processor
</objective>

<execution_context>
@./.claude/agents/gsd-executor.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-email-observation-pipeline/03-RESEARCH.md
@.planning/phases/03-email-observation-pipeline/03-01-SUMMARY.md

@backend/src/services/graphClient.ts
@backend/src/utils/graph.ts
@backend/src/models/EmailEvent.ts
@backend/src/models/WebhookSubscription.ts
@backend/src/models/Mailbox.ts
@backend/src/jobs/queues.ts
@backend/src/jobs/processors/tokenRefresh.ts
@backend/src/auth/tokenManager.ts
@backend/src/config/redis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Metadata extractor and event collector services</name>
  <files>
    backend/src/services/metadataExtractor.ts
    backend/src/services/eventCollector.ts
  </files>
  <action>
    **1. Create `backend/src/services/metadataExtractor.ts`:**

    Extracts metadata from Graph message objects into a shape compatible with the IEmailEvent interface. NEVER includes body content.

    - Export the `GraphMessage` interface (typed based on research):
      ```typescript
      export interface GraphMessage {
        id: string;
        subject?: string;
        from?: { emailAddress: { name?: string; address?: string } };
        receivedDateTime?: string;
        isRead?: boolean;
        importance?: string;
        hasAttachments?: boolean;
        conversationId?: string;
        categories?: string[];
        parentFolderId?: string;
        internetMessageId?: string;
        internetMessageHeaders?: Array<{ name: string; value: string }>;
        flag?: { flagStatus: string };
        '@removed'?: { reason: string };
      }
      ```

    - Export `function extractMetadata(msg: GraphMessage): Partial<IEmailEvent>`:
      - Extract sender email from `msg.from?.emailAddress?.address` -- lowercase it
      - Extract sender domain by splitting email at `@`
      - Extract sender name from `msg.from?.emailAddress?.name`
      - Check `internetMessageHeaders` for newsletter indicators:
        - `hasListUnsubscribe`: any header with name `list-unsubscribe` (case-insensitive)
        - `isAutomated`: any header with name `x-auto-response-suppress` (case-insensitive)
        - `isNewsletter`: set to `true` if `hasListUnsubscribe` is true (heuristic)
      - Return object matching IEmailEvent shape:
        - `messageId`: `msg.id`
        - `internetMessageId`: `msg.internetMessageId`
        - `subject`: `msg.subject`
        - `sender`: `{ name, email, domain }`
        - `receivedAt`: parsed from `msg.receivedDateTime`
        - `importance`: `msg.importance?.toLowerCase()` cast to `'low' | 'normal' | 'high'`, default `'normal'`
        - `hasAttachments`: `msg.hasAttachments ?? false`
        - `conversationId`: `msg.conversationId`
        - `categories`: `msg.categories ?? []`
        - `isRead`: `msg.isRead ?? false`
        - `metadata`: `{ hasListUnsubscribe, isNewsletter, isAutomated }`
      - Do NOT include: body, bodyPreview, or any content fields

    **2. Create `backend/src/services/eventCollector.ts`:**

    Processes change notifications into EmailEvent documents.

    - Import `graphFetch`, `GraphApiError` from `./graphClient.js`
    - Import `extractMetadata` and `GraphMessage` from `./metadataExtractor.js`
    - Import `buildSelectParam` from `../utils/graph.js`
    - Import `getAccessTokenForMailbox` from `../auth/tokenManager.js`
    - Import `EmailEvent` from `../models/EmailEvent.js`
    - Import `WebhookSubscription` from `../models/WebhookSubscription.js`
    - Import `Mailbox` from `../models/Mailbox.js`
    - Import `logger`

    Export `async function saveEmailEvent(eventData: Partial<IEmailEvent>): Promise<boolean>`:
    - Try `EmailEvent.create(eventData)`
    - On success, return `true`
    - On error with `code === 11000` (duplicate key), return `false` (silently skip)
    - On any other error, re-throw

    Export `async function processChangeNotification(notification: { subscriptionId: string; changeType: string; resource: string; resourceData?: { id: string; '@odata.type'?: string } }): Promise<void>`:
    - Look up the WebhookSubscription by `notification.subscriptionId` to get `userId` and `mailboxId`
    - If not found, log warning and return (subscription may have been deleted)
    - Get access token via `getAccessTokenForMailbox(mailboxId)`
    - Update `WebhookSubscription.lastNotificationAt` to now (fire-and-forget, no await needed)

    Handle by changeType:

    **`deleted`:**
    - The notification only gives us the message ID (from `notification.resourceData.id`). We cannot fetch the message from Graph (it is deleted).
    - Create an EmailEvent with `eventType: 'deleted'`, `messageId: notification.resourceData.id`, `userId`, `mailboxId`, `timestamp: new Date()`
    - To fill in metadata (sender, subject, etc.), look up the most recent EmailEvent for this messageId to copy metadata from a prior `arrived` or `moved` event. If no prior event exists, store with minimal data (messageId and eventType only -- metadata will be sparse but the event is still recorded).
    - Call `saveEmailEvent()`

    **`created`:**
    - Fetch the message details from Graph: `GET /users/{mailboxEmail}/messages/{messageId}?$select={buildSelectParam('message')}`
    - Extract metadata via `extractMetadata(graphMessage)`
    - Create EmailEvent with `eventType: 'arrived'`, all extracted metadata, `userId`, `mailboxId`, `toFolder: graphMessage.parentFolderId`
    - Call `saveEmailEvent()`

    **`updated`:**
    - Fetch the message details from Graph (same as created)
    - Detect if this is a MOVE by checking parentFolderId:
      - Look up the most recent EmailEvent for this messageId to get the last known `parentFolderId` (check `toFolder` field)
      - If `parentFolderId` has changed, create a `'moved'` event with `fromFolder: lastKnownFolder`, `toFolder: graphMessage.parentFolderId`
    - If not a move, detect read/flag/category changes:
      - Look up previous event state. If `isRead` changed from false to true, create a `'read'` event
      - If `flag?.flagStatus` changed to `'flagged'`, create a `'flagged'` event
      - If `categories` changed, create a `'categorized'` event
    - If nothing detectably changed, log at debug level and skip (Graph may send duplicate updates)
    - Call `saveEmailEvent()` for each detected event type

    Error handling:
    - If `graphFetch` returns 404 (message was deleted between notification and fetch), log and skip
    - If `getAccessTokenForMailbox` fails (token expired), log error with mailboxId. The token refresh job will handle reconnection; this notification is lost but delta sync will catch it.
    - Wrap all operations in try/catch and log errors with full context (subscriptionId, changeType, messageId)
  </action>
  <verify>
    1. `cd /home/admin/claude/MSEDB && docker compose exec backend npx tsc --noEmit` passes
    2. metadataExtractor.ts exports extractMetadata and GraphMessage interface
    3. eventCollector.ts exports processChangeNotification and saveEmailEvent
    4. extractMetadata returns no body-related fields
    5. saveEmailEvent catches error code 11000 and returns false
  </verify>
  <done>
    Metadata extractor converts Graph message objects to EmailEvent-compatible data without body content. Event collector fetches message details for created/updated notifications, detects moves via parentFolderId comparison, and stores deduplicated events via compound unique index.
  </done>
</task>

<task type="auto">
  <name>Task 2: Webhook events BullMQ processor</name>
  <files>
    backend/src/jobs/processors/webhookEvents.ts
    backend/src/jobs/queues.ts
  </files>
  <action>
    **1. Create `backend/src/jobs/processors/webhookEvents.ts`:**

    BullMQ processor that handles incoming change notifications from the webhook-events queue.

    - Import `type { Job }` from `'bullmq'`
    - Import `processChangeNotification` from `'../../services/eventCollector.js'`
    - Import `logger`

    Export `async function processWebhookEvent(job: Job): Promise<void>`:
    - Extract `notification` and `subscriptionId` from `job.data`
    - Log job start: `logger.info('Processing webhook event', { jobId: job.id, changeType: notification.changeType, subscriptionId })`
    - Call `await processChangeNotification(notification)`
    - Log job completion
    - Errors propagate to BullMQ for retry handling (the queue already has `attempts: 3, backoff: exponential` from schedulerJobOpts -- but for ad-hoc jobs, set the same retry options when enqueuing in webhooks.ts). Actually, ad-hoc jobs added via `.add()` need their own opts. Update the webhook handler's `.add()` call in webhooks.ts to include `{ attempts: 3, backoff: { type: 'exponential', delay: 5000 } }` as the third parameter.

    **2. Update `backend/src/jobs/queues.ts`:**

    Wire the real webhook-events processor:
    - Import `{ processWebhookEvent }` from `'./processors/webhookEvents.js'`
    - Replace the placeholder processor for `'webhook-events'` with `processWebhookEvent` in the processorMap

    **3. Update webhook handler retry opts:**

    In `backend/src/routes/webhooks.ts`, when calling `queues['webhook-events'].add()` and `queues['webhook-renewal'].add()`, pass job options as the third argument:
    ```typescript
    { attempts: 3, backoff: { type: 'exponential', delay: 5000 } }
    ```
    This ensures ad-hoc jobs from webhook notifications get the same retry behavior as scheduled jobs.
  </action>
  <verify>
    1. `cd /home/admin/claude/MSEDB && docker compose exec backend npx tsc --noEmit` passes
    2. webhookEvents.ts exports processWebhookEvent
    3. queues.ts processorMap maps 'webhook-events' to processWebhookEvent (not placeholder)
    4. webhooks.ts add() calls include retry options
  </verify>
  <done>
    Webhook events processor wired into BullMQ, calls processChangeNotification for each notification. Both webhook-events and webhook-renewal queues now have real processors (no placeholders remaining for Phase 3 queues). Ad-hoc jobs include retry options.
  </done>
</task>

</tasks>

<verification>
- `docker compose exec backend npx tsc --noEmit` compiles cleanly
- No body-related fields in metadataExtractor.ts output
- saveEmailEvent handles duplicate key errors (code 11000) silently
- processChangeNotification handles all three changeTypes: created, updated, deleted
- Move detection compares parentFolderId against last known state
- Both webhook-events and webhook-renewal processors are real (not placeholders)
- GraphMessage interface matches Graph API message resource type
</verification>

<success_criteria>
- Webhook notifications flow through BullMQ into EmailEvent documents
- Metadata (sender, subject, folder, timestamps) extracted correctly from Graph messages
- Body content is never fetched or stored
- Duplicate events silently rejected by compound unique index
- Message moves detected by parentFolderId change and stored as 'moved' events
- Newsletter/automated indicators detected from internet message headers
</success_criteria>

<output>
After completion, create `.planning/phases/03-email-observation-pipeline/03-02-SUMMARY.md`
</output>
