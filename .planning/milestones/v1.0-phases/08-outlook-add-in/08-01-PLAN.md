---
phase: 08-outlook-add-in
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - addin/package.json
  - addin/tsconfig.json
  - addin/webpack.config.js
  - addin/manifest.xml
  - addin/src/taskpane/taskpane.html
  - addin/src/taskpane/taskpane.tsx
  - addin/src/commands/commands.html
  - addin/src/commands/commands.ts
  - addin/src/auth/msalConfig.ts
  - addin/src/auth/authHelper.ts
  - addin/src/api/backendClient.ts
  - addin/src/types/index.ts
  - addin/assets/icon-16.png
  - addin/assets/icon-32.png
  - addin/assets/icon-80.png
  - backend/src/auth/ssoMiddleware.ts
  - backend/src/middleware/security.ts
  - backend/src/config/index.ts
  - backend/package.json
  - backend/src/server.ts
  - backend/src/auth/routes.ts
autonomous: true
requirements:
  - PLUG-01
  - PLUG-04

must_haves:
  truths:
    - "Outlook Add-in manifest validates without errors via npx office-addin-manifest validate"
    - "Add-in webpack build completes successfully (npm run build in addin/)"
    - "Backend SSO middleware validates Azure AD Bearer tokens and maps to MSEDB users"
    - "CORS allows requests from the add-in origin alongside the existing frontend origin"
    - "The /auth/me endpoint accepts both cookie-based auth (dashboard) and Bearer token auth (add-in)"
  artifacts:
    - path: "addin/manifest.xml"
      provides: "Office Add-in manifest with MessageReadCommandSurface ribbon button and taskpane"
      contains: "MessageReadCommandSurface"
    - path: "addin/package.json"
      provides: "Add-in dependencies including @azure/msal-browser, React, Webpack, Office.js types"
      contains: "@azure/msal-browser"
    - path: "addin/webpack.config.js"
      provides: "Webpack config with HTTPS dev server, HtmlWebpackPlugin for taskpane.html and commands.html"
      contains: "HtmlWebpackPlugin"
    - path: "addin/src/auth/msalConfig.ts"
      provides: "MSAL NAA configuration with createNestablePublicClientApplication"
      contains: "createNestablePublicClientApplication"
    - path: "addin/src/auth/authHelper.ts"
      provides: "Token acquisition helper with silent+popup fallback and NAA support check"
      contains: "acquireTokenSilent"
    - path: "addin/src/api/backendClient.ts"
      provides: "HTTP client that attaches Bearer token to all MSEDB backend API calls"
      contains: "Authorization"
    - path: "backend/src/auth/ssoMiddleware.ts"
      provides: "requireSsoAuth middleware validating Azure AD JWT via JWKS"
      contains: "jwks-rsa"
    - path: "addin/src/taskpane/taskpane.tsx"
      provides: "React entry point gated behind Office.onReady()"
      contains: "Office.onReady"
  key_links:
    - from: "addin/src/auth/authHelper.ts"
      to: "addin/src/auth/msalConfig.ts"
      via: "imports MSAL instance"
      pattern: "import.*msalConfig"
    - from: "addin/src/api/backendClient.ts"
      to: "addin/src/auth/authHelper.ts"
      via: "gets token before each API call"
      pattern: "getAccessToken"
    - from: "backend/src/auth/ssoMiddleware.ts"
      to: "backend/src/auth/middleware.ts"
      via: "shares JwtPayload type and sets req.user"
      pattern: "req\\.user"
    - from: "backend/src/auth/routes.ts"
      to: "backend/src/auth/ssoMiddleware.ts"
      via: "/auth/me accepts both cookie and SSO auth"
      pattern: "requireSsoAuth|requireAuth"

user_setup:
  - service: azure-ad
    why: "SSO token validation requires Azure AD app registration updates for the add-in"
    env_vars:
      - name: ADDIN_URL
        source: "The HTTPS URL where the add-in is served (e.g., https://localhost:3000 for dev)"
    dashboard_config:
      - task: "Add SPA platform with redirect URI brk-multihub://localhost:3000"
        location: "Azure Portal > App Registrations > MSEDB > Authentication > Add Platform > Single-page application"
      - task: "Expose API with scope access_as_user"
        location: "Azure Portal > App Registrations > MSEDB > Expose an API > Add a scope"
      - task: "Pre-authorize Office client ID ea5a67f6-b6f3-4338-b240-c655ddc3cc8e"
        location: "Azure Portal > App Registrations > MSEDB > Expose an API > Add authorized client applications"
      - task: "Set Application ID URI to api://localhost:3000/{client-id}"
        location: "Azure Portal > App Registrations > MSEDB > Expose an API > Application ID URI"
---

<objective>
Scaffold the Outlook Add-in package with manifest, webpack build tooling, NAA SSO authentication, and backend SSO token validation middleware.

Purpose: Establishes the add-in as a separate deployable package within the monorepo with working auth flow. Without this foundation, no add-in feature can communicate with the MSEDB backend.
Output: A buildable addin/ package with valid manifest, MSAL NAA auth, backend SSO middleware, and CORS configuration -- ready for feature UI in Plan 02.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-outlook-add-in/08-RESEARCH.md
@backend/src/config/index.ts
@backend/src/middleware/security.ts
@backend/src/auth/middleware.ts
@backend/src/auth/routes.ts
@backend/src/server.ts
@backend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold addin/ package with manifest, webpack, and Office.js entry points</name>
  <files>
    addin/package.json
    addin/tsconfig.json
    addin/webpack.config.js
    addin/manifest.xml
    addin/src/taskpane/taskpane.html
    addin/src/taskpane/taskpane.tsx
    addin/src/commands/commands.html
    addin/src/commands/commands.ts
    addin/src/types/index.ts
    addin/assets/icon-16.png
    addin/assets/icon-32.png
    addin/assets/icon-80.png
  </files>
  <action>
    Create the `addin/` directory at the project root as a separate package (NOT inside frontend/ or backend/).

    **addin/package.json:**
    - name: "msedb-addin", private: true, type: "module"
    - Dependencies: `@azure/msal-browser` ^3.x, `react` ^19.0.0, `react-dom` ^19.0.0, `tailwindcss` ^4.0.0, `lucide-react` ^0.574.0
    - DevDependencies: `typescript` ^5.7.0, `webpack` ^5.x, `webpack-cli` ^5.x, `webpack-dev-server` ^5.x, `html-webpack-plugin` ^5.x, `copy-webpack-plugin` ^12.x, `css-loader`, `style-loader`, `ts-loader`, `office-addin-dev-certs`, `@types/office-js`, `@types/react`, `@types/react-dom`
    - Scripts: `build: webpack --mode production`, `start: webpack serve --mode development`, `validate: npx office-addin-manifest validate manifest.xml`

    **addin/tsconfig.json:**
    - target: ES2020, module: ES2020, moduleResolution: bundler, jsx: react-jsx
    - strict: true, esModuleInterop: true, skipLibCheck: true
    - types: ["office-js"]
    - outDir: dist, rootDir: src

    **addin/webpack.config.js:**
    - CommonJS format (module.exports) since webpack config files are not ESM
    - Two entry points: `taskpane` (src/taskpane/taskpane.tsx) and `commands` (src/commands/commands.ts)
    - ts-loader for .ts/.tsx files
    - css-loader + style-loader for .css files
    - HtmlWebpackPlugin for both taskpane.html and commands.html (one instance per entry)
    - CopyWebpackPlugin to copy assets/ to dist/assets/
    - DefinePlugin to inject `BACKEND_URL` from env var `MSEDB_BACKEND_URL` (default `http://172.16.219.222:8010`)
    - devServer: https (use `await devCerts.getHttpsServerOptions()` from office-addin-dev-certs), port 3000, headers with Access-Control-Allow-Origin: *, hot: true, allowedHosts: 'all'
    - resolve.extensions: ['.ts', '.tsx', '.js', '.jsx']

    **addin/manifest.xml:**
    - Use the full XML manifest template from 08-RESEARCH.md (Pattern 4 + full manifest template)
    - Generate a real GUID for the <Id> element using uuid v4
    - xsi:type="MailApp" targeting Mailbox host
    - Requirements: Mailbox 1.3
    - VersionOverrides V1_1 with MessageReadCommandSurface extension point
    - Single ribbon button "Email Manager" that opens the taskpane (ShowTaskpane action)
    - WebApplicationInfo section with placeholder client ID (read from env at build time is not possible for XML -- use a clear placeholder like YOUR_AZURE_AD_CLIENT_ID with a comment)
    - Resource URLs pointing to https://localhost:3000/ (dev defaults)
    - FormSettings with ItemRead form and DesktopSettings

    **addin/src/taskpane/taskpane.html:**
    - Minimal HTML5 page, charset UTF-8
    - Script tag for Office.js CDN: `https://appsforoffice.microsoft.com/lib/1/hosted/office.js`
    - Empty div with id="root" for React mount
    - Link to Tailwind CSS (will be bundled by webpack)

    **addin/src/taskpane/taskpane.tsx:**
    - Import React and ReactDOM
    - Gate rendering behind `Office.onReady()` -- do NOT render until Office.js is initialized
    - Render a placeholder `<div>MSEDB Add-in Loading...</div>` into #root (full App component comes in Plan 02)
    - Export nothing (side-effect module)

    **addin/src/commands/commands.html:**
    - Minimal HTML5 page with Office.js CDN script tag
    - No visible body content (function commands are headless)

    **addin/src/commands/commands.ts:**
    - Call `Office.onReady()` on load
    - Register a single function command `showTaskpane` that is a no-op (placeholder for future use)
    - Call `Office.actions.associate("showTaskpane", showTaskpane)` to register

    **addin/src/types/index.ts:**
    - Export interfaces: `SenderInfo { email: string; name: string; domain: string }`
    - Export type: `WhitelistAction = 'whitelist' | 'blacklist'`
    - Export type: `ActionScope = 'sender' | 'domain'`
    - Export interface: `MailboxInfo { id: string; email: string; displayName: string; isConnected: boolean }`
    - Export interface: `ActionResult { success: boolean; message: string }`

    **addin/assets/ icons:**
    - Create simple placeholder PNG icons at 16x16, 32x32, and 80x80 pixels
    - Use a solid color square (e.g., blue #2563EB) as placeholder -- these can be replaced later with proper branding
    - Generate via a minimal script or copy from a data URI. If programmatic PNG generation is too complex, create minimal valid 1-color PNG files using Node.js Buffer with PNG header bytes

    **Important:** Do NOT use Vite (the main frontend uses Vite, but Office Add-in tooling is built around Webpack). Do NOT include the full dashboard in the add-in.
  </action>
  <verify>
    1. `cd /home/admin/claude/MSEDB/addin && npm install` completes without errors
    2. `cd /home/admin/claude/MSEDB/addin && npx webpack --mode production` builds successfully to dist/
    3. dist/ contains taskpane.html, commands.html, and assets/icon-*.png
    4. `ls addin/dist/taskpane.js addin/dist/commands.js` both exist
  </verify>
  <done>
    addin/ package exists at project root with valid package.json, tsconfig.json, webpack.config.js, manifest.xml, entry points (taskpane + commands), type definitions, and placeholder icons. `npm install && npm run build` succeeds. The manifest contains a MessageReadCommandSurface with a ShowTaskpane button.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement NAA SSO auth in add-in and backend SSO middleware with CORS update</name>
  <files>
    addin/src/auth/msalConfig.ts
    addin/src/auth/authHelper.ts
    addin/src/api/backendClient.ts
    backend/src/auth/ssoMiddleware.ts
    backend/src/middleware/security.ts
    backend/src/config/index.ts
    backend/package.json
    backend/src/server.ts
    backend/src/auth/routes.ts
  </files>
  <action>
    **ADD-IN SIDE (3 files):**

    **addin/src/auth/msalConfig.ts:**
    - Import `createNestablePublicClientApplication` and `type PublicClientApplication` from `@azure/msal-browser`
    - Export `msalConfig` object with:
      - `auth.clientId`: Read from `AZURE_AD_CLIENT_ID` via webpack DefinePlugin (declare global const)
      - `auth.authority`: `https://login.microsoftonline.com/${AZURE_AD_TENANT_ID}`
      - `cache.cacheLocation`: "localStorage"
    - Export `tokenRequest` with `scopes: ["api://${ADDIN_DOMAIN}/${AZURE_AD_CLIENT_ID}/access_as_user"]`
      - Use DefinePlugin constants for domain and client ID
    - Export async `initMsal()` that creates and caches the MSAL instance using `createNestablePublicClientApplication`
    - Export `getMsalInstance()` getter that throws if not initialized
    - Declare webpack DefinePlugin globals at top of file: `declare const AZURE_AD_CLIENT_ID: string; declare const AZURE_AD_TENANT_ID: string; declare const ADDIN_DOMAIN: string;`

    **addin/src/auth/authHelper.ts:**
    - Import `InteractionRequiredAuthError` from `@azure/msal-browser`
    - Import `initMsal`, `getMsalInstance`, `tokenRequest` from msalConfig
    - Export async `checkNaaSupport(): boolean` that checks `Office.context.requirements.isSetSupported("NestedAppAuth", "1.1")`
    - Export async `getAccessToken(): Promise<string>`:
      1. Call `initMsal()` (idempotent)
      2. Try `acquireTokenSilent(tokenRequest)` -- return accessToken on success
      3. On `InteractionRequiredAuthError`, try `acquireTokenPopup(tokenRequest)` -- return accessToken
      4. On other errors, throw with descriptive message
    - Export async `isAuthenticated(): Promise<boolean>` that tries getAccessToken and returns true/false

    **addin/src/api/backendClient.ts:**
    - Import `getAccessToken` from authHelper
    - Declare `declare const BACKEND_URL: string;` for webpack DefinePlugin
    - Export async function `apiRequest<T>(path: string, options?: RequestInit): Promise<T>`:
      1. Get token via `getAccessToken()`
      2. `fetch(BACKEND_URL + path, { ...options, headers: { Authorization: 'Bearer ' + token, 'Content-Type': 'application/json', ...options?.headers } })`
      3. If response not ok, throw with status and response body
      4. Return `response.json()` as T
    - Export convenience functions:
      - `getMailboxes(): Promise<MailboxInfo[]>` -- GET /auth/me, return data.mailboxes
      - `getWhitelist(mailboxId: string)` -- GET /api/mailboxes/{id}/whitelist
      - `updateWhitelist(mailboxId: string, data: { senders?: string[]; domains?: string[] })` -- PUT /api/mailboxes/{id}/whitelist
      - `createRule(data: { mailboxId: string; name: string; conditions: Record<string, unknown>; actions: Array<{ actionType: string }> })` -- POST /api/rules

    **Update addin/webpack.config.js** to add DefinePlugin entries:
    - `BACKEND_URL`: `JSON.stringify(process.env.MSEDB_BACKEND_URL || 'http://172.16.219.222:8010')`
    - `AZURE_AD_CLIENT_ID`: `JSON.stringify(process.env.AZURE_AD_CLIENT_ID || 'YOUR_CLIENT_ID')`
    - `AZURE_AD_TENANT_ID`: `JSON.stringify(process.env.AZURE_AD_TENANT_ID || 'YOUR_TENANT_ID')`
    - `ADDIN_DOMAIN`: `JSON.stringify(process.env.ADDIN_DOMAIN || 'localhost:3000')`

    **BACKEND SIDE (5 files):**

    **backend/package.json:**
    - Add dependency: `jwks-rsa` ^3.x (for JWKS key rotation in SSO token validation)

    **backend/src/config/index.ts:**
    - Add `addinUrl: process.env.ADDIN_URL || 'https://localhost:3000'` to the config object

    **backend/src/auth/ssoMiddleware.ts:**
    - Create new file implementing `requireSsoAuth` middleware
    - Import `jwks-rsa` (use `jwksClient` from `jwks-rsa`)
    - Import `jwt` from `jsonwebtoken` (already a backend dependency)
    - Import `User` model, `UnauthorizedError`, `config`
    - Create JWKS client: `jwksClient({ jwksUri: 'https://login.microsoftonline.com/${config.azureAdTenantId}/discovery/v2.0/keys', cache: true, rateLimit: true })`
    - Implement `getSigningKey(header: jwt.JwtHeader)` function that returns the public key
    - Export `requireSsoAuth(req, res, next)`:
      1. Extract Bearer token from `req.headers.authorization`
      2. If no Bearer token, throw `UnauthorizedError('No Bearer token')`
      3. Verify JWT with `jwt.verify()` using the JWKS signing key
      4. Validation options: `audience: config.azureAdClientId`, `issuer: 'https://login.microsoftonline.com/${config.azureAdTenantId}/v2.0'`, `algorithms: ['RS256']`
      5. Check decoded payload `scp` includes 'access_as_user'
      6. Find User by `email: payload.preferred_username.toLowerCase()`
      7. Set `req.user = { userId: user._id.toString(), email: user.email, role: user.role }`
      8. Call `next()`
    - Export `requireSsoOrCookieAuth(req, res, next)`:
      - If `req.headers.authorization?.startsWith('Bearer ')`, delegate to `requireSsoAuth`
      - Else delegate to existing `requireAuth` (cookie-based)
      - This composite middleware lets routes accept either auth method

    **backend/src/middleware/security.ts:**
    - Change CORS origin from `config.appUrl` (single string) to a function that checks against allowed origins: `[config.appUrl, config.addinUrl]`
    - The origin callback should accept requests from either origin, or no origin (for non-browser clients)
    - Keep all other security middleware (helmet, compression, body parsing) unchanged

    **backend/src/auth/routes.ts:**
    - Change the `/auth/me` route to use `requireSsoOrCookieAuth` instead of `requireAuth`
    - Import `requireSsoOrCookieAuth` from `./ssoMiddleware.js`
    - This allows the add-in to call /auth/me with a Bearer token to resolve mailbox IDs

    **backend/src/server.ts:**
    - No structural changes needed -- the ssoMiddleware is imported by routes.ts, not mounted globally
    - The CORS change in security.ts applies automatically since configureSecurityMiddleware is already called

    **Run `cd /home/admin/claude/MSEDB/backend && npm install`** after updating package.json to install jwks-rsa.
  </action>
  <verify>
    1. `cd /home/admin/claude/MSEDB/backend && npm install` completes (jwks-rsa installed)
    2. `cd /home/admin/claude/MSEDB/backend && npx tsc --noEmit` compiles without errors
    3. `cd /home/admin/claude/MSEDB/addin && npm run build` compiles with auth modules included
    4. `grep -r "requireSsoAuth" backend/src/auth/ssoMiddleware.ts` confirms middleware exists
    5. `grep -r "requireSsoOrCookieAuth" backend/src/auth/routes.ts` confirms /auth/me accepts both auth methods
    6. `grep "addinUrl" backend/src/config/index.ts` confirms new config field
    7. `grep -r "allowedOrigins\|addinUrl" backend/src/middleware/security.ts` confirms CORS update
  </verify>
  <done>
    Add-in has MSAL NAA configuration with silent+popup token acquisition and NAA support detection. Backend has requireSsoAuth middleware that validates Azure AD SSO tokens via JWKS, and a composite requireSsoOrCookieAuth middleware. The /auth/me endpoint accepts both cookie (dashboard) and Bearer token (add-in) auth. CORS allows both frontend and add-in origins. jwks-rsa dependency installed.
  </done>
</task>

</tasks>

<verification>
1. `cd /home/admin/claude/MSEDB/addin && npm install && npm run build` -- full add-in build succeeds
2. `cd /home/admin/claude/MSEDB/backend && npm install && npx tsc --noEmit` -- backend compiles with new SSO middleware
3. `ls addin/dist/taskpane.html addin/dist/commands.html addin/dist/assets/` -- output artifacts exist
4. `grep "MessageReadCommandSurface" addin/manifest.xml` -- manifest has correct extension point
5. `grep "createNestablePublicClientApplication" addin/src/auth/msalConfig.ts` -- NAA auth configured
6. `grep "jwks-rsa" backend/package.json` -- SSO validation dependency present
</verification>

<success_criteria>
- addin/ package builds successfully with webpack
- manifest.xml declares MessageReadCommandSurface with ShowTaskpane button
- MSAL NAA auth configured with silent+popup token flow
- Backend SSO middleware validates Azure AD Bearer tokens via JWKS
- /auth/me accepts both cookie and Bearer token auth
- CORS configured for both frontend and add-in origins
- All TypeScript compiles without errors in both packages
</success_criteria>

<output>
After completion, create `.planning/phases/08-outlook-add-in/08-01-SUMMARY.md`
</output>
