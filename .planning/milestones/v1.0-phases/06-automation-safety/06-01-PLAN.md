---
phase: 06-automation-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/ruleEngine.ts
  - backend/src/services/whitelistService.ts
  - backend/src/services/actionExecutor.ts
  - backend/src/services/stagingManager.ts
  - backend/src/models/StagedEmail.ts
autonomous: true
requirements: [AUTO-01, AUTO-03, SAFE-01, SAFE-02, SAFE-04]

must_haves:
  truths:
    - "Emails from whitelisted senders/domains are never affected by automation rules"
    - "When a user pauses automation (kill switch), no emails are auto-processed"
    - "Emails matched by a delete rule appear in the staging folder instead of being deleted immediately"
    - "Staged emails remain available for rescue until the processor executes them after the grace period"
  artifacts:
    - path: "backend/src/services/ruleEngine.ts"
      provides: "Core rule evaluation with kill switch + whitelist + first-match-wins"
      exports: ["evaluateRulesForMessage", "matchesConditions"]
    - path: "backend/src/services/whitelistService.ts"
      provides: "Whitelist check for per-mailbox and org-wide protection"
      exports: ["isWhitelisted"]
    - path: "backend/src/services/actionExecutor.ts"
      provides: "Graph API action execution with staging for destructive actions"
      exports: ["executeActions"]
    - path: "backend/src/services/stagingManager.ts"
      provides: "Staging folder creation, staged email CRUD, rescue"
      exports: ["ensureStagingFolder", "createStagedEmail", "rescueStagedEmail"]
  key_links:
    - from: "backend/src/services/ruleEngine.ts"
      to: "User.preferences.automationPaused"
      via: "User.findById select automationPaused"
      pattern: "User\\.findById.*automationPaused"
    - from: "backend/src/services/ruleEngine.ts"
      to: "backend/src/services/whitelistService.ts"
      via: "isWhitelisted call before rule evaluation"
      pattern: "isWhitelisted"
    - from: "backend/src/services/actionExecutor.ts"
      to: "backend/src/services/stagingManager.ts"
      via: "stageForDeletion for delete actions"
      pattern: "createStagedEmail"
---

<objective>
Build the core rule evaluation engine, action executor, whitelist service, and staging manager -- the backend service layer that powers all automation and safety mechanisms.

Purpose: These services form the foundation for the entire automation pipeline. The rule engine is called when incoming emails arrive to determine which rule (if any) should fire. The action executor translates rule actions into Graph API calls, routing destructive actions through a staging folder. The whitelist service protects specified senders/domains from automation.

Output: Four service files providing rule evaluation, action execution, whitelist checking, and staging management. Plus the StagedEmail TTL index fix.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-automation-safety/06-RESEARCH.md

@backend/src/models/Rule.ts
@backend/src/models/StagedEmail.ts
@backend/src/models/AuditLog.ts
@backend/src/models/Mailbox.ts
@backend/src/models/User.ts
@backend/src/services/graphClient.ts
@backend/src/services/eventCollector.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rule engine, whitelist service, and StagedEmail TTL fix</name>
  <files>
    backend/src/services/ruleEngine.ts
    backend/src/services/whitelistService.ts
    backend/src/models/StagedEmail.ts
  </files>
  <action>
    **1. Create `backend/src/services/whitelistService.ts`:**
    - Export `isWhitelisted(mailboxId: Types.ObjectId, senderEmail: string): Promise<boolean>`
    - Check per-mailbox whitelist: `Mailbox.findById(mailboxId).select('settings.whitelistedSenders settings.whitelistedDomains')`
    - Extract sender domain from email address
    - Check if senderEmail is in `whitelistedSenders` (case-insensitive) OR sender domain is in `whitelistedDomains` (case-insensitive)
    - For org-wide whitelist in v1: check if any Mailbox doc with `userId` of an admin user has this sender/domain whitelisted (simple approach -- a dedicated OrgSettings model can come in Phase 7)
    - Actually, simpler: store org-wide whitelist in Redis as two Sets (`org:whitelist:senders` and `org:whitelist:domains`). Export `addToOrgWhitelist`, `removeFromOrgWhitelist`, `getOrgWhitelist` functions that read/write these Redis sets via `getRedisClient()`. Check org whitelist in `isWhitelisted` after per-mailbox check.
    - Import `getRedisClient` from `../config/redis.js`
    - Import `Mailbox` from `../models/Mailbox.js`

    **2. Create `backend/src/services/ruleEngine.ts`:**
    - Export `evaluateRulesForMessage(userId: Types.ObjectId, mailboxId: Types.ObjectId, message: GraphMessage, accessToken: string): Promise<{ matched: boolean; ruleId?: string; actions?: IRuleAction[] }>`
    - Import `User` from models, `isWhitelisted` from whitelistService, `Rule` and `IRuleAction` from models
    - Import `GraphMessage` type from `../services/metadataExtractor.js` (it is already exported there)
    - Step 1: Check kill switch -- `User.findById(userId).select('preferences.automationPaused')`. If `automationPaused === true`, return `{ matched: false }`
    - Step 2: Check whitelist -- `isWhitelisted(mailboxId, message.from.emailAddress.address)`. If whitelisted, return `{ matched: false }`
    - Step 3: Query rules -- `Rule.find({ userId, mailboxId, isEnabled: true }).sort({ priority: 1 })`. First-match-wins: iterate rules, call `matchesConditions(rule.conditions, message)`, return first match with `{ matched: true, ruleId: rule._id.toString(), actions: rule.actions }`
    - If no match, return `{ matched: false }`
    - Export `matchesConditions(conditions: IRuleConditions, message: GraphMessage): boolean`
    - Match logic:
      - If `conditions.senderEmail` is set, check `message.from.emailAddress.address` (case-insensitive)
      - If `conditions.senderDomain` is set, check domain part of `message.from.emailAddress.address` (case-insensitive)
      - If `conditions.subjectContains` is set, check `message.subject.toLowerCase().includes(...)`
      - If `conditions.fromFolder` is set, check `message.parentFolderId === conditions.fromFolder`
      - ALL set conditions must match (AND logic)
    - Use the `IRuleConditions` type from `../models/Rule.js`

    **3. Fix StagedEmail TTL index:**
    - The existing TTL index `{ expiresAt: 1 }, { expireAfterSeconds: 0 }` will auto-delete documents at expiresAt, BEFORE the staging processor can execute them
    - Remove the TTL index on `expiresAt`
    - Add a new field `cleanupAt` (type Date) to IStagedEmail interface and schema
    - Add TTL index on `cleanupAt` with `expireAfterSeconds: 0` -- this field will be set to `expiresAt + 7 days` when creating staged emails, giving the processor time to execute and keeping records for audit
    - Update the existing index from `{ expiresAt: 1 }, { expireAfterSeconds: 0 }` to `{ cleanupAt: 1 }, { expireAfterSeconds: 0 }`
    - Keep the compound index on `userId + status + expiresAt` as-is (the staging processor queries by this)
    - Add `cleanupAt` as optional Date field to IStagedEmail
  </action>
  <verify>
    Run `npx tsc --noEmit` from backend directory -- should pass with no type errors.
    Verify ruleEngine.ts exports evaluateRulesForMessage and matchesConditions.
    Verify whitelistService.ts exports isWhitelisted.
    Verify StagedEmail.ts no longer has TTL index on expiresAt, has TTL index on cleanupAt.
  </verify>
  <done>
    Rule engine evaluates kill switch -> whitelist -> priority rules (first-match-wins).
    Whitelist service checks per-mailbox and org-wide (Redis) whitelists.
    StagedEmail TTL index fixed to use cleanupAt field (expiresAt + 7 days buffer).
  </done>
</task>

<task type="auto">
  <name>Task 2: Action executor and staging manager</name>
  <files>
    backend/src/services/actionExecutor.ts
    backend/src/services/stagingManager.ts
  </files>
  <action>
    **1. Create `backend/src/services/stagingManager.ts`:**
    - Import `graphFetch` from `./graphClient.js`, `StagedEmail` from models, `Mailbox` from models, `AuditLog` from models, `getIO` from `../config/socket.js`, logger
    - Export `ensureStagingFolder(mailboxEmail: string, accessToken: string): Promise<string>`:
      - Check if folder exists: `graphFetch('/users/${mailboxEmail}/mailFolders?$filter=displayName eq \'MSEDB Staging\'&$select=id,displayName', accessToken)`
      - Parse response, if `value.length > 0` return `value[0].id`
      - Otherwise create: `graphFetch('/users/${mailboxEmail}/mailFolders', accessToken, { method: 'POST', body: JSON.stringify({ displayName: 'MSEDB Staging' }) })`
      - Return the new folder id
      - Cache the folder ID in a module-level Map keyed by mailboxEmail to avoid repeated Graph API calls
    - Export `createStagedEmail(params: { userId, mailboxId, ruleId, messageId, originalFolder, actions }): Promise<IStagedEmail>`:
      - Set `stagedAt` to now, `expiresAt` to 24 hours from now, `cleanupAt` to 7 days after expiresAt, `status` to 'staged'
      - Create StagedEmail document
      - Create AuditLog entry with action 'email_staged', targetType 'email', targetId messageId, details including ruleId and actions, undoable true
      - Emit Socket.IO event `staging:new` to `user:${userId}` room with staged email data (for real-time badge updates)
      - Return the saved document
    - Export `rescueStagedEmail(stagedEmailId: string, userId: Types.ObjectId): Promise<IStagedEmail>`:
      - Find StagedEmail by id and userId, status 'staged'
      - If not found, throw NotFoundError
      - Update status to 'rescued', rescuedAt to now
      - Create AuditLog entry with action 'email_rescued'
      - Return updated document
    - Export `batchRescueStagedEmails(ids: string[], userId: Types.ObjectId): Promise<number>`:
      - Use `StagedEmail.updateMany({ _id: { $in: ids }, userId, status: 'staged' }, { status: 'rescued', rescuedAt: new Date() })`
      - Create AuditLog entries for each
      - Return count of modified documents

    **2. Create `backend/src/services/actionExecutor.ts`:**
    - Import `graphFetch`, `GraphApiError` from `./graphClient.js`
    - Import `createStagedEmail` from `./stagingManager.js`
    - Import `ensureStagingFolder` from `./stagingManager.js`
    - Import `Mailbox` from models, `Rule` from models, `AuditLog` from models, logger
    - Import `IRuleAction` from `../models/Rule.js`
    - Export `executeActions(params: { mailboxEmail, messageId, actions: IRuleAction[], ruleId, userId, mailboxId, originalFolder, accessToken }): Promise<void>`:
      - Sort actions by `order` field (ascending, nulls last)
      - For each action:
        - `delete`: Route to staging -- call `ensureStagingFolder(mailboxEmail, accessToken)` to get staging folder ID, then `graphFetch('/users/${mailboxEmail}/messages/${messageId}/move', accessToken, { method: 'POST', body: { destinationId: stagingFolderId } })`, then `createStagedEmail({ userId, mailboxId, ruleId, messageId, originalFolder, actions: [{ actionType: 'delete' }] })`
        - `move`: `graphFetch('/users/${mailboxEmail}/messages/${messageId}/move', accessToken, { method: 'POST', body: { destinationId: action.toFolder } })`
        - `markRead`: `graphFetch('/users/${mailboxEmail}/messages/${messageId}', accessToken, { method: 'PATCH', body: { isRead: true } })`
        - `categorize`: `graphFetch('/users/${mailboxEmail}/messages/${messageId}', accessToken, { method: 'PATCH', body: { categories: [action.category] } })`
        - `archive`: `graphFetch('/users/${mailboxEmail}/messages/${messageId}/move', accessToken, { method: 'POST', body: { destinationId: 'archive' } })`
        - `flag`: `graphFetch('/users/${mailboxEmail}/messages/${messageId}', accessToken, { method: 'PATCH', body: { flag: { flagStatus: 'flagged' } } })`
      - Handle 404 gracefully (message already moved/deleted by user) -- log warning but don't fail
      - After all actions, update rule stats: `Rule.findByIdAndUpdate(ruleId, { $inc: { 'stats.totalExecutions': 1, 'stats.emailsProcessed': 1 }, $set: { 'stats.lastExecutedAt': new Date() } })`
      - Create AuditLog entry with action 'rule_executed', targetType 'email', targetId messageId, details including ruleId, actions taken, undoable true, mailboxId
    - NEVER use permanentDelete -- all deletes go through staging
  </action>
  <verify>
    Run `npx tsc --noEmit` from backend directory -- should pass with no type errors.
    Verify actionExecutor.ts exports executeActions.
    Verify stagingManager.ts exports ensureStagingFolder, createStagedEmail, rescueStagedEmail, batchRescueStagedEmails.
    Grep for 'permanentDelete' in actionExecutor.ts -- should return zero matches (SAFE-03 compliance).
  </verify>
  <done>
    Action executor translates rule actions to Graph API calls with staging for destructive actions.
    Staging manager creates/rescues staged emails with audit logging and Socket.IO notifications.
    No permanentDelete anywhere -- all deletes routed through staging.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes from backend/
- All 4 new service files exist and export their key functions
- StagedEmail model has cleanupAt field and TTL index on cleanupAt (not expiresAt)
- No occurrence of 'permanentDelete' in any service file
- Rule engine evaluation order: kill switch -> whitelist -> priority rules
</verification>

<success_criteria>
- Rule engine can evaluate messages against user rules with correct priority ordering
- Whitelist service blocks automation on protected senders/domains
- Action executor routes delete actions through staging folder
- Staging manager creates/rescues staged emails with audit trail
- StagedEmail TTL index will not auto-delete documents before processor runs
</success_criteria>

<output>
After completion, create `.planning/phases/06-automation-safety/06-01-SUMMARY.md`
</output>
