---
phase: 06-automation-safety
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/ruleConverter.ts
  - backend/src/services/undoService.ts
autonomous: true
requirements: [AUTO-04, SAFE-03]

must_haves:
  truths:
    - "Approved pattern is converted into a Rule document with correct conditions and multi-action support"
    - "User can undo any automated action within 48 hours via soft-delete only"
  artifacts:
    - path: "backend/src/services/ruleConverter.ts"
      provides: "Pattern-to-rule conversion with multi-action support"
      exports: ["convertPatternToRule"]
    - path: "backend/src/services/undoService.ts"
      provides: "Undo automated actions within 48h via Graph API reversals"
      exports: ["undoAction"]
  key_links:
    - from: "backend/src/services/ruleConverter.ts"
      to: "Pattern.condition -> Rule.conditions"
      via: "field mapping"
      pattern: "conditions\\.senderEmail.*condition\\.senderEmail"
    - from: "backend/src/services/undoService.ts"
      to: "AuditLog.undoneAt"
      via: "marks audit entries as undone"
      pattern: "undoneAt"
---

<objective>
Build the pattern-to-rule converter and undo service -- completing the automation lifecycle from pattern approval to rule creation, and providing the safety net for reversing automated actions.

Purpose: The converter bridges the pattern detection engine (Phase 5) to the rule engine (Plan 01). When a user approves a pattern, it creates a Rule document with the correct conditions and actions. The undo service enables users to reverse any automated action within 48 hours, ensuring no action is irreversible.

Output: Two service files -- ruleConverter.ts for pattern-to-rule conversion and undoService.ts for action reversal.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-automation-safety/06-RESEARCH.md

@backend/src/models/Pattern.ts
@backend/src/models/Rule.ts
@backend/src/models/AuditLog.ts
@backend/src/services/graphClient.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pattern-to-rule converter</name>
  <files>backend/src/services/ruleConverter.ts</files>
  <action>
    Create `backend/src/services/ruleConverter.ts`:

    - Import `Pattern, IPattern` from `../models/Pattern.js`
    - Import `Rule, IRule, IRuleConditions, IRuleAction` from `../models/Rule.js`
    - Import `AuditLog` from `../models/AuditLog.js`
    - Import `Types` from `mongoose`
    - Import logger

    **Export `convertPatternToRule(patternId: string | Types.ObjectId, userId: Types.ObjectId): Promise<IRule>`:**
    - Find pattern by id and userId, verify status is 'approved'. Throw NotFoundError if not found, ConflictError if not approved
    - Check if a Rule already exists for this pattern: `Rule.findOne({ sourcePatternId: patternId })`
    - If exists, return the existing rule (idempotent)
    - Map pattern condition to rule conditions:
      - `pattern.condition.senderEmail` -> `rule.conditions.senderEmail`
      - `pattern.condition.senderDomain` -> `rule.conditions.senderDomain`
      - `pattern.condition.subjectPattern` -> `rule.conditions.subjectContains`
      - `pattern.condition.fromFolder` -> `rule.conditions.fromFolder`
    - Map pattern suggestedAction to rule actions array (AUTO-01 multi-action):
      - Primary action: `{ actionType: pattern.suggestedAction.actionType, toFolder: pattern.suggestedAction.toFolder, category: pattern.suggestedAction.category, order: 0 }`
      - If actionType is 'move' or 'archive', also add `{ actionType: 'markRead', order: 1 }` as secondary action (common pattern: move + mark read)
      - This gives multi-action support. Additional actions can be added via rule edit later.
    - Generate rule name from pattern: e.g., `"Auto: ${pattern.suggestedAction.actionType} emails from ${pattern.condition.senderEmail || pattern.condition.senderDomain}"`
    - Find the highest existing priority for this user+mailbox and assign `priority = max + 1` (append to end)
    - Create Rule document with: userId, mailboxId: pattern.mailboxId, name, sourcePatternId: pattern._id, isEnabled: true, priority, conditions, actions, stats defaults, scope: 'user'
    - Create AuditLog entry: action 'rule_created', targetType 'rule', targetId: rule._id, details: { sourcePatternId, conditions, actions, name }
    - Return the created Rule

    **Export `buildRuleName(pattern: IPattern): string`:**
    - Helper to generate human-readable rule name from pattern
    - Format: "Auto: {actionType} from {senderEmail|senderDomain|'matching subjects'}"
    - Capitalize first letter of actionType
  </action>
  <verify>
    Run `npx tsc --noEmit` from backend directory.
    Verify ruleConverter.ts exports convertPatternToRule and buildRuleName.
  </verify>
  <done>
    Pattern approval creates a Rule with correctly mapped conditions, multi-action support (move + markRead), and priority ordering.
    Conversion is idempotent -- calling twice for the same pattern returns the existing rule.
    AuditLog entry created on rule creation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Undo service for reversing automated actions</name>
  <files>backend/src/services/undoService.ts</files>
  <action>
    Create `backend/src/services/undoService.ts`:

    - Import `graphFetch`, `GraphApiError` from `./graphClient.js`
    - Import `AuditLog, IAuditLog` from `../models/AuditLog.js`
    - Import `Mailbox` from `../models/Mailbox.js`
    - Import `getAccessTokenForMailbox` from `../auth/tokenManager.js`
    - Import `Types` from `mongoose`
    - Import logger
    - Import `NotFoundError, ValidationError` from `../middleware/errorHandler.js`

    **Export `undoAction(auditLogId: string, userId: Types.ObjectId): Promise<IAuditLog>`:**
    - Find AuditLog by id and userId
    - Validate: throw NotFoundError if not found
    - Validate: throw ValidationError if `undoable !== true`
    - Validate: throw ValidationError if `undoneAt` is already set (already undone)
    - Validate: throw ValidationError if `createdAt` is more than 48 hours ago ('Undo window has expired')
    - Get the mailbox email and access token from the audit entry's mailboxId
    - Based on audit `action` type, reverse the action:

    **For 'rule_executed' (a rule moved/categorized/flagged an email):**
    - Read `details.actions` array and `details.originalFolder` (the folder the email was in before the rule acted)
    - For each action in reverse order:
      - If action was 'move' or 'archive': move email back to originalFolder via `POST /users/{email}/messages/{messageId}/move` with `{ destinationId: originalFolder }`
      - If action was 'markRead': set `{ isRead: false }` via PATCH
      - If action was 'categorize': remove categories via PATCH `{ categories: [] }`
      - If action was 'flag': unflag via PATCH `{ flag: { flagStatus: 'notFlagged' } }`
      - If action was 'delete': this went through staging, handled separately

    **For 'email_executed' (staging processor executed a staged delete):**
    - The email was moved to Deleted Items by the staging processor
    - Move it back: `POST /users/{email}/messages/{messageId}/move` with `{ destinationId: details.originalFolder }`
    - Handle 404 gracefully: email may have been permanently purged by Exchange retention. Log warning and update audit entry with `details.undoFailed: true, details.undoReason: 'Message no longer available'`

    **For 'email_staged' (email is in staging folder):**
    - This is equivalent to rescue -- update StagedEmail status to 'rescued' and move email back
    - Import StagedEmail model for this case

    - After successful reversal: update audit entry with `undoneAt: new Date(), undoneBy: userId`
    - Create a new AuditLog entry with action 'undo_action', details referencing the original auditLogId
    - Return the updated audit entry

    - Handle 404 from Graph API gracefully -- the message may have been permanently deleted by Exchange. Set undoneAt but add `details.undoPartial: true` note.
    - NEVER call permanentDelete (SAFE-03)
  </action>
  <verify>
    Run `npx tsc --noEmit` from backend directory.
    Verify undoService.ts exports undoAction.
    Grep for 'permanentDelete' -- should return zero matches.
  </verify>
  <done>
    Users can undo rule_executed, email_executed, and email_staged actions within 48 hours.
    Undo reverses Graph API actions (move back, unread, uncategorize).
    Handles 404 gracefully when message is no longer available.
    Never uses permanentDelete.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes from backend/
- ruleConverter.ts and undoService.ts exist with correct exports
- No occurrence of 'permanentDelete' in any file
- Pattern-to-rule mapping correctly translates conditions and actions
</verification>

<success_criteria>
- Approved patterns can be converted to Rule documents with multi-action support
- Undo service can reverse move, markRead, categorize, flag, and staging actions within 48h
- All undo operations use soft-delete only (move to original folder, never permanentDelete)
</success_criteria>

<output>
After completion, create `.planning/phases/06-automation-safety/06-02-SUMMARY.md`
</output>
