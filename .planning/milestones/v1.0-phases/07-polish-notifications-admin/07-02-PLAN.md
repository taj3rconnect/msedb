---
phase: 07-polish-notifications-admin
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - frontend/src/stores/notificationStore.ts
  - frontend/src/api/notifications.ts
  - frontend/src/api/settings.ts
  - frontend/src/hooks/useNotifications.ts
  - frontend/src/hooks/useSettings.ts
  - frontend/src/hooks/useSocket.ts
  - frontend/src/components/notifications/NotificationBell.tsx
  - frontend/src/components/notifications/NotificationDropdown.tsx
  - frontend/src/components/notifications/NotificationItem.tsx
  - frontend/src/components/layout/Topbar.tsx
  - frontend/src/components/settings/PreferencesSection.tsx
  - frontend/src/components/settings/MailboxSection.tsx
  - frontend/src/components/settings/WhitelistSection.tsx
  - frontend/src/components/settings/DataManagement.tsx
  - frontend/src/pages/SettingsPage.tsx
  - frontend/src/App.tsx
autonomous: true
requirements:
  - DASH-03
  - PAGE-06

must_haves:
  truths:
    - "Bell icon in the Topbar shows unread notification count"
    - "Clicking the bell opens a dropdown listing recent notifications"
    - "New notifications arrive in real-time via Socket.IO without page refresh"
    - "Marking a notification as read updates the unread count immediately"
    - "Settings page has tabbed sections for preferences, mailboxes, whitelists, and data"
    - "Working hours and aggressiveness can be saved without affecting the kill switch"
    - "User can export their data as a downloadable JSON file"
    - "User can delete their account with confirmation dialog"
  artifacts:
    - path: "frontend/src/stores/notificationStore.ts"
      provides: "Zustand store for notification unread count and dropdown state"
      exports: ["useNotificationStore"]
    - path: "frontend/src/components/notifications/NotificationBell.tsx"
      provides: "Bell icon with unread badge in Topbar"
      exports: ["NotificationBell"]
    - path: "frontend/src/pages/SettingsPage.tsx"
      provides: "Settings page replacing ComingSoonPage"
      exports: ["SettingsPage"]
    - path: "frontend/src/hooks/useNotifications.ts"
      provides: "TanStack Query hooks for notification API"
      exports: ["useNotifications", "useUnreadCount", "useMarkRead", "useMarkAllRead"]
    - path: "frontend/src/hooks/useSettings.ts"
      provides: "TanStack Query hooks for settings API"
      exports: ["useSettings", "useUpdatePreferences", "useExportData", "useDeleteData"]
  key_links:
    - from: "frontend/src/hooks/useSocket.ts"
      to: "frontend/src/stores/notificationStore.ts"
      via: "Socket.IO notification:new -> incrementUnread"
      pattern: "notification:new.*incrementUnread"
    - from: "frontend/src/components/notifications/NotificationBell.tsx"
      to: "frontend/src/stores/notificationStore.ts"
      via: "useNotificationStore for unread count"
      pattern: "useNotificationStore"
    - from: "frontend/src/components/layout/Topbar.tsx"
      to: "frontend/src/components/notifications/NotificationBell.tsx"
      via: "NotificationBell rendered in Topbar"
      pattern: "<NotificationBell"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/pages/SettingsPage.tsx"
      via: "Route element replacement"
      pattern: "element:.*<SettingsPage"
---

<objective>
Build the in-app notification system (bell icon, dropdown, real-time push) and the Settings page with all four tabbed sections.

Purpose: DASH-03 requires real-time notification delivery visible from any page. PAGE-06 requires a full settings page replacing the ComingSoonPage placeholder. These are tightly coupled -- both are user-facing features consuming the backend APIs from Plan 01.

Output: NotificationBell in Topbar with live unread count, notification dropdown with mark-read, Settings page with preferences/mailboxes/whitelists/data tabs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-polish-notifications-admin/07-RESEARCH.md
@.planning/phases/07-polish-notifications-admin/07-01-SUMMARY.md
@frontend/src/App.tsx
@frontend/src/hooks/useSocket.ts
@frontend/src/components/layout/Topbar.tsx
@frontend/src/stores/authStore.ts
@frontend/src/stores/uiStore.ts
@frontend/src/api/client.ts
@frontend/src/hooks/useKillSwitch.ts
@frontend/src/hooks/useStaging.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notification system -- store, API, hooks, bell icon, dropdown, Socket.IO listener</name>
  <files>
    frontend/src/stores/notificationStore.ts
    frontend/src/api/notifications.ts
    frontend/src/hooks/useNotifications.ts
    frontend/src/hooks/useSocket.ts
    frontend/src/components/notifications/NotificationBell.tsx
    frontend/src/components/notifications/NotificationDropdown.tsx
    frontend/src/components/notifications/NotificationItem.tsx
    frontend/src/components/layout/Topbar.tsx
  </files>
  <action>
    **Create `frontend/src/stores/notificationStore.ts`:**
    - Zustand store following the existing authStore.ts pattern (no persist middleware needed).
    - State: `unreadCount: number`, `isDropdownOpen: boolean`.
    - Actions: `setUnreadCount(count: number)`, `incrementUnread()` (adds 1), `decrementUnread()` (subtracts 1, floor at 0), `setDropdownOpen(open: boolean)`.
    - Export `useNotificationStore`.

    **Create `frontend/src/api/notifications.ts`:**
    - Follow the existing patterns API client pattern (see `frontend/src/api/patterns.ts`).
    - Define TypeScript interfaces:
      ```
      NotificationItem { id: string; type: string; title: string; message: string; priority: string; isRead: boolean; readAt?: string; createdAt: string; relatedEntity?: { entityType: string; entityId: string } }
      NotificationsResponse { notifications: NotificationItem[]; total: number; unreadCount: number }
      UnreadCountResponse { count: number }
      ```
    - Functions:
      - `fetchNotifications(limit?: number, offset?: number): Promise<NotificationsResponse>` -- GET /api/notifications
      - `fetchUnreadCount(): Promise<UnreadCountResponse>` -- GET /api/notifications/unread-count
      - `markAsRead(id: string): Promise<NotificationItem>` -- PATCH /api/notifications/{id}/read
      - `markAllAsRead(): Promise<{ success: boolean }>` -- PATCH /api/notifications/read-all

    **Create `frontend/src/hooks/useNotifications.ts`:**
    - Follow the existing useStaging.ts hook pattern.
    - `useNotifications(limit?: number, offset?: number)` -- useQuery with key ['notifications', limit, offset], calls fetchNotifications. On success, call `useNotificationStore.getState().setUnreadCount(data.unreadCount)` to sync Zustand store.
    - `useUnreadCount()` -- useQuery with key ['notifications-unread'], calls fetchUnreadCount. On success, sync to Zustand store. Set `staleTime: 60_000` (1 min), no `refetchInterval` (Socket.IO handles real-time).
    - `useMarkRead()` -- useMutation calling markAsRead, on success invalidate ['notifications'] and ['notifications-unread'], also call `decrementUnread()` on the store.
    - `useMarkAllRead()` -- useMutation calling markAllAsRead, on success invalidate both query keys, call `setUnreadCount(0)`.

    **Update `frontend/src/hooks/useSocket.ts`:**
    - Add import for `useNotificationStore` from `@/stores/notificationStore`.
    - Add a new Socket.IO listener inside the existing useEffect, after the `staging:new` listener:
      ```typescript
      socket.on('notification:new', () => {
        useNotificationStore.getState().incrementUnread();
        queryClient.invalidateQueries({ queryKey: ['notifications'] });
      });
      ```
    - Note: Access Zustand store via `.getState()` (not hooks) since we're inside a non-React callback. This is the correct Zustand pattern for external access.

    **Create `frontend/src/components/notifications/NotificationItem.tsx`:**
    - Receives: `notification` (NotificationItem type), `onMarkRead` callback.
    - Renders: icon based on `notification.type` (Brain for pattern_detected, Shield for rule_executed, Clock for staging_alert, Bell for system/others from lucide-react), title in font-medium, message in text-muted-foreground text-sm, relative time (date-fns `formatDistanceToNow`).
    - Unread notifications have a left blue border (`border-l-2 border-primary`) and slightly different background (`bg-accent/50`).
    - Clicking an unread notification calls `onMarkRead(notification.id)`.
    - Show priority badge only for 'high' priority (Badge variant="destructive" with "Urgent").

    **Create `frontend/src/components/notifications/NotificationDropdown.tsx`:**
    - Uses `useNotifications(10, 0)` to fetch recent 10 notifications when dropdown is open.
    - Uses `useMarkRead()` and `useMarkAllRead()` mutations.
    - Header row: "Notifications" title + "Mark all read" button (text variant, only shown if unreadCount > 0).
    - Body: shadcn ScrollArea (max-h-80) rendering NotificationItem for each notification.
    - Empty state: EmptyState component with "No notifications yet" message.
    - Footer: if total > 10, show "View all" text (can be a placeholder for now -- no dedicated notifications page needed).

    **Create `frontend/src/components/notifications/NotificationBell.tsx`:**
    - Uses Popover from shadcn/ui (import from @/components/ui/popover).
    - Uses `useNotificationStore` for `unreadCount`, `isDropdownOpen`, `setDropdownOpen`.
    - Uses `useUnreadCount()` hook to fetch initial count on mount (syncs to Zustand store).
    - PopoverTrigger: button with Bell icon (lucide-react). If `unreadCount > 0`, show Badge (variant="destructive") with count (cap at "99+" for > 99).
    - PopoverContent: renders NotificationDropdown, align="end", width w-80.
    - Follow the exact pattern from 07-RESEARCH.md NotificationBell example.

    **Update `frontend/src/components/layout/Topbar.tsx`:**
    - Import `NotificationBell` from `@/components/notifications/NotificationBell`.
    - Add `<NotificationBell />` in the right-side flex container, between `<KillSwitch />` and the user avatar `<DropdownMenu>`.
  </action>
  <verify>
    - `npx tsc --noEmit --project frontend/tsconfig.json` passes (all new components compile).
    - Grep `notification:new` in `frontend/src/hooks/useSocket.ts` confirms Socket.IO listener added.
    - Grep `NotificationBell` in `frontend/src/components/layout/Topbar.tsx` confirms bell is in Topbar.
    - `ls frontend/src/components/notifications/` shows NotificationBell.tsx, NotificationDropdown.tsx, NotificationItem.tsx.
  </verify>
  <done>
    Bell icon appears in the Topbar with unread badge. Clicking opens a popover dropdown with recent notifications. Socket.IO pushes new notifications in real-time (incrementing unread count). Mark-read and mark-all-read mutations update both server and local state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Settings page with tabbed sections, replacing ComingSoonPage</name>
  <files>
    frontend/src/api/settings.ts
    frontend/src/hooks/useSettings.ts
    frontend/src/components/settings/PreferencesSection.tsx
    frontend/src/components/settings/MailboxSection.tsx
    frontend/src/components/settings/WhitelistSection.tsx
    frontend/src/components/settings/DataManagement.tsx
    frontend/src/pages/SettingsPage.tsx
    frontend/src/App.tsx
  </files>
  <action>
    **Create `frontend/src/api/settings.ts`:**
    - Follow existing API client pattern (apiFetch from @/api/client).
    - Types:
      ```
      UserPreferences { automationPaused: boolean; workingHoursStart: number; workingHoursEnd: number; aggressiveness: 'conservative' | 'moderate' | 'aggressive' }
      MailboxInfo { id: string; email: string; displayName?: string; isConnected: boolean; tokenExpiresAt?: string; tokenHealthy: boolean; lastSyncAt?: string; whitelistedSenders: string[]; whitelistedDomains: string[] }
      SettingsResponse { user: { email: string; displayName?: string; preferences: UserPreferences; createdAt: string }; mailboxes: MailboxInfo[] }
      ```
    - Functions:
      - `fetchSettings(): Promise<SettingsResponse>` -- GET /api/settings
      - `updatePreferences(prefs: Partial<UserPreferences>): Promise<{ preferences: UserPreferences }>` -- PATCH /api/user/preferences (uses existing user route)
      - `exportData(): Promise<Blob>` -- GET /api/settings/export-data. Use `fetch` directly (not apiFetch) since we need the raw response as a Blob for download. Set `credentials: 'include'`.
      - `deleteData(): Promise<{ message: string }>` -- DELETE /api/settings/delete-data
      - `updateMailboxWhitelist(mailboxId: string, data: { whitelistedSenders: string[]; whitelistedDomains: string[] })` -- PUT /api/mailboxes/{mailboxId}/whitelist (existing endpoint from Phase 6)

    **Create `frontend/src/hooks/useSettings.ts`:**
    - `useSettings()` -- useQuery key ['settings'], calls fetchSettings.
    - `useUpdatePreferences()` -- useMutation calling updatePreferences, on success invalidate ['settings'] and show toast via `sonner` ("Preferences saved").
    - `useExportData()` -- useMutation. On success, create a Blob URL, create a temporary `<a>` element, set href to Blob URL and download attribute to filename, click it, revoke URL. Show toast "Data exported".
    - `useDeleteData()` -- useMutation calling deleteData, on success redirect to /login (window.location.href = '/login' since session is cleared).
    - `useUpdateWhitelist()` -- useMutation calling updateMailboxWhitelist, on success invalidate ['settings'] and show toast.

    **Create `frontend/src/components/settings/PreferencesSection.tsx`:**
    - Form with save button (NOT auto-save -- per Research anti-pattern warning).
    - Working hours: two Slider components (shadcn) for start (0-23) and end (0-23) with labels showing the hour values (e.g., "9 AM", "5 PM"). Use local state, submit as batch.
    - Aggressiveness: RadioGroup (shadcn) with three options:
      - Conservative: "Higher thresholds, fewer suggestions. Best for new users."
      - Moderate: "Balanced thresholds. Recommended for most users."
      - Aggressive: "Lower thresholds, more suggestions. For power users."
    - Save button calls `useUpdatePreferences` with only changed fields.
    - Load initial values from `useSettings()` data.
    - Note: Do NOT include automationPaused here -- it's controlled by the KillSwitch in the Topbar (per decision 04-02).

    **Create `frontend/src/components/settings/MailboxSection.tsx`:**
    - Show a Card for each connected mailbox from settings data.
    - Each card shows: email (bold), displayName, connection status badge (green "Connected" / red "Disconnected"), token health (progress bar -- green if tokenHealthy, red if not, show expiry time via formatDistanceToNow), last sync time.
    - No reconnect/disconnect actions for now (would require OAuth flow -- keep it informational).
    - If no mailboxes, show EmptyState with "No mailboxes connected" message.

    **Create `frontend/src/components/settings/WhitelistSection.tsx`:**
    - For each mailbox, show a section with:
      - Sender whitelist: Textarea (shadcn) with one email per line. Pre-filled from mailbox.whitelistedSenders.
      - Domain whitelist: Textarea with one domain per line. Pre-filled from mailbox.whitelistedDomains.
      - Save button per mailbox calling `useUpdateWhitelist`.
    - Parse textarea values by splitting on newlines, trimming, filtering empty strings.
    - Show mailbox email as section header.

    **Create `frontend/src/components/settings/DataManagement.tsx`:**
    - "Export Data" section: Description text ("Download all your data as a JSON file"), Button calling useExportData mutation.
    - "Delete Account" section: Description text ("Permanently delete your account and all associated data. This action cannot be undone."), destructive Button opening an AlertDialog (already installed shadcn component).
    - AlertDialog confirmation: Title "Delete Account?", description "This will permanently delete your account, all email events, patterns, rules, and audit logs. You will be logged out immediately.", cancel and confirm buttons. The confirm button triggers useDeleteData mutation.

    **Create `frontend/src/pages/SettingsPage.tsx`:**
    - Export named `SettingsPage` function component.
    - Page header: "Settings" title, "Manage your preferences and account" description.
    - Uses Tabs component (shadcn) with 4 tabs:
      - "Preferences" -> PreferencesSection
      - "Mailboxes" -> MailboxSection
      - "Whitelists" -> WhitelistSection
      - "Data" -> DataManagement
    - Default tab: "Preferences".
    - Uses `useSettings()` hook at the page level, passes data down to sections.
    - Shows LoadingSpinner while settings loading.

    **Update `frontend/src/App.tsx`:**
    - Replace `import { ComingSoonPage } from '@/pages/ComingSoonPage';` with `import { SettingsPage } from '@/pages/SettingsPage';`.
    - Replace the settings route element from `<ComingSoonPage title="Settings" />` to `<SettingsPage />`.
    - Keep the ComingSoonPage import ONLY if other routes still use it. Check: no other route uses ComingSoonPage, so remove the import entirely.
  </action>
  <verify>
    - `npx tsc --noEmit --project frontend/tsconfig.json` passes (all settings components compile).
    - Grep `SettingsPage` in `frontend/src/App.tsx` confirms ComingSoonPage replaced.
    - `ls frontend/src/components/settings/` shows all 4 section files.
    - `ls frontend/src/pages/SettingsPage.tsx` confirms page exists.
  </verify>
  <done>
    Settings page replaces ComingSoonPage with 4 tabbed sections. Preferences tab saves working hours and aggressiveness without touching kill switch. Mailboxes tab shows connection status and token health. Whitelists tab allows per-mailbox sender/domain whitelist editing. Data tab provides export and delete-account functionality with confirmation dialog.
  </done>
</task>

</tasks>

<verification>
- Frontend TypeScript compiles: `npx tsc --noEmit --project frontend/tsconfig.json`
- NotificationBell visible in Topbar (between KillSwitch and avatar)
- Socket.IO listener for `notification:new` in useSocket.ts
- Settings page renders with Tabs at /settings route
- ComingSoonPage no longer used for settings route
- No polling for notifications (Socket.IO handles real-time)
- Preferences save uses field-level PATCH (not full object replacement)
</verification>

<success_criteria>
- Bell icon shows unread count badge in Topbar on every page
- Clicking bell opens popover dropdown with paginated notifications
- Socket.IO `notification:new` event increments unread count without refresh
- Mark-read and mark-all-read update badge count immediately
- Settings page has 4 tabs: Preferences, Mailboxes, Whitelists, Data
- Working hours slider and aggressiveness radio save successfully
- Mailbox cards show connection status and token health
- Whitelist textarea saves per-mailbox sender/domain lists
- Export data downloads a JSON file
- Delete account shows confirmation, then clears session and redirects to login
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-notifications-admin/07-02-SUMMARY.md`
</output>
